// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object_detection/protos/faster_rcnn.proto

package object_detection.protos;

public final class FasterRcnnOuterClass {
  private FasterRcnnOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface FasterRcnnOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.FasterRcnn)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Whether to construct only the Region Proposal Network (RPN).
     * </pre>
     *
     * <code>optional int32 number_of_stages = 1 [default = 2];</code>
     */
    boolean hasNumberOfStages();
    /**
     * <pre>
     * Whether to construct only the Region Proposal Network (RPN).
     * </pre>
     *
     * <code>optional int32 number_of_stages = 1 [default = 2];</code>
     */
    int getNumberOfStages();

    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 3;</code>
     */
    boolean hasNumClasses();
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 3;</code>
     */
    int getNumClasses();

    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     */
    boolean hasImageResizer();
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     */
    object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer();
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     */
    object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder();

    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     */
    boolean hasFeatureExtractor();
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     */
    object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getFeatureExtractor();
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     */
    object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder getFeatureExtractorOrBuilder();

    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     */
    boolean hasFirstStageAnchorGenerator();
    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     */
    object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator getFirstStageAnchorGenerator();
    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     */
    object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder getFirstStageAnchorGeneratorOrBuilder();

    /**
     * <pre>
     * Atrous rate for the convolution op applied to the
     * `first_stage_features_to_crop` tensor to obtain box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
     */
    boolean hasFirstStageAtrousRate();
    /**
     * <pre>
     * Atrous rate for the convolution op applied to the
     * `first_stage_features_to_crop` tensor to obtain box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
     */
    int getFirstStageAtrousRate();

    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     */
    boolean hasFirstStageBoxPredictorConvHyperparams();
    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     */
    object_detection.protos.HyperparamsOuterClass.Hyperparams getFirstStageBoxPredictorConvHyperparams();
    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     */
    object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getFirstStageBoxPredictorConvHyperparamsOrBuilder();

    /**
     * <pre>
     * Kernel size to use for the convolution op just prior to RPN box
     * predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
     */
    boolean hasFirstStageBoxPredictorKernelSize();
    /**
     * <pre>
     * Kernel size to use for the convolution op just prior to RPN box
     * predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
     */
    int getFirstStageBoxPredictorKernelSize();

    /**
     * <pre>
     * Output depth for the convolution op just prior to RPN box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
     */
    boolean hasFirstStageBoxPredictorDepth();
    /**
     * <pre>
     * Output depth for the convolution op just prior to RPN box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
     */
    int getFirstStageBoxPredictorDepth();

    /**
     * <pre>
     * The batch size to use for computing the first stage objectness and
     * location losses.
     * </pre>
     *
     * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
     */
    boolean hasFirstStageMinibatchSize();
    /**
     * <pre>
     * The batch size to use for computing the first stage objectness and
     * location losses.
     * </pre>
     *
     * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
     */
    int getFirstStageMinibatchSize();

    /**
     * <pre>
     * Fraction of positive examples per image for the RPN.
     * </pre>
     *
     * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
     */
    boolean hasFirstStagePositiveBalanceFraction();
    /**
     * <pre>
     * Fraction of positive examples per image for the RPN.
     * </pre>
     *
     * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
     */
    float getFirstStagePositiveBalanceFraction();

    /**
     * <pre>
     * Non max suppression score threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
     */
    boolean hasFirstStageNmsScoreThreshold();
    /**
     * <pre>
     * Non max suppression score threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
     */
    float getFirstStageNmsScoreThreshold();

    /**
     * <pre>
     * Non max suppression IOU threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
     */
    boolean hasFirstStageNmsIouThreshold();
    /**
     * <pre>
     * Non max suppression IOU threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
     */
    float getFirstStageNmsIouThreshold();

    /**
     * <pre>
     * Maximum number of RPN proposals retained after first stage postprocessing.
     * </pre>
     *
     * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
     */
    boolean hasFirstStageMaxProposals();
    /**
     * <pre>
     * Maximum number of RPN proposals retained after first stage postprocessing.
     * </pre>
     *
     * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
     */
    int getFirstStageMaxProposals();

    /**
     * <pre>
     * First stage RPN localization loss weight.
     * </pre>
     *
     * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
     */
    boolean hasFirstStageLocalizationLossWeight();
    /**
     * <pre>
     * First stage RPN localization loss weight.
     * </pre>
     *
     * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
     */
    float getFirstStageLocalizationLossWeight();

    /**
     * <pre>
     * First stage RPN objectness loss weight.
     * </pre>
     *
     * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
     */
    boolean hasFirstStageObjectnessLossWeight();
    /**
     * <pre>
     * First stage RPN objectness loss weight.
     * </pre>
     *
     * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
     */
    float getFirstStageObjectnessLossWeight();

    /**
     * <pre>
     * Output size (width and height are set to be the same) of the initial
     * bilinear interpolation based cropping during ROI pooling.
     * </pre>
     *
     * <code>optional int32 initial_crop_size = 18;</code>
     */
    boolean hasInitialCropSize();
    /**
     * <pre>
     * Output size (width and height are set to be the same) of the initial
     * bilinear interpolation based cropping during ROI pooling.
     * </pre>
     *
     * <code>optional int32 initial_crop_size = 18;</code>
     */
    int getInitialCropSize();

    /**
     * <pre>
     * Kernel size of the max pool op on the cropped feature map during
     * ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_kernel_size = 19;</code>
     */
    boolean hasMaxpoolKernelSize();
    /**
     * <pre>
     * Kernel size of the max pool op on the cropped feature map during
     * ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_kernel_size = 19;</code>
     */
    int getMaxpoolKernelSize();

    /**
     * <pre>
     * Stride of the max pool op on the cropped feature map during ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_stride = 20;</code>
     */
    boolean hasMaxpoolStride();
    /**
     * <pre>
     * Stride of the max pool op on the cropped feature map during ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_stride = 20;</code>
     */
    int getMaxpoolStride();

    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     */
    boolean hasSecondStageBoxPredictor();
    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     */
    object_detection.protos.BoxPredictorOuterClass.BoxPredictor getSecondStageBoxPredictor();
    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     */
    object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder getSecondStageBoxPredictorOrBuilder();

    /**
     * <pre>
     * The batch size per image used for computing the classification and refined
     * location loss of the box classifier.
     * Note that this field is ignored if `hard_example_miner` is configured.
     * </pre>
     *
     * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
     */
    boolean hasSecondStageBatchSize();
    /**
     * <pre>
     * The batch size per image used for computing the classification and refined
     * location loss of the box classifier.
     * Note that this field is ignored if `hard_example_miner` is configured.
     * </pre>
     *
     * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
     */
    int getSecondStageBatchSize();

    /**
     * <pre>
     * Fraction of positive examples to use per image for the box classifier.
     * </pre>
     *
     * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
     */
    boolean hasSecondStageBalanceFraction();
    /**
     * <pre>
     * Fraction of positive examples to use per image for the box classifier.
     * </pre>
     *
     * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
     */
    float getSecondStageBalanceFraction();

    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     */
    boolean hasSecondStagePostProcessing();
    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     */
    object_detection.protos.PostProcessingOuterClass.PostProcessing getSecondStagePostProcessing();
    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     */
    object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder getSecondStagePostProcessingOrBuilder();

    /**
     * <pre>
     * Second stage refined localization loss weight.
     * </pre>
     *
     * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
     */
    boolean hasSecondStageLocalizationLossWeight();
    /**
     * <pre>
     * Second stage refined localization loss weight.
     * </pre>
     *
     * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
     */
    float getSecondStageLocalizationLossWeight();

    /**
     * <pre>
     * Second stage classification loss weight
     * </pre>
     *
     * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
     */
    boolean hasSecondStageClassificationLossWeight();
    /**
     * <pre>
     * Second stage classification loss weight
     * </pre>
     *
     * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
     */
    float getSecondStageClassificationLossWeight();

    /**
     * <pre>
     * Second stage instance mask loss weight. Note that this is only applicable
     * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
     * predict instance masks.
     * </pre>
     *
     * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
     */
    boolean hasSecondStageMaskPredictionLossWeight();
    /**
     * <pre>
     * Second stage instance mask loss weight. Note that this is only applicable
     * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
     * predict instance masks.
     * </pre>
     *
     * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
     */
    float getSecondStageMaskPredictionLossWeight();

    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     */
    boolean hasHardExampleMiner();
    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     */
    object_detection.protos.Losses.HardExampleMiner getHardExampleMiner();
    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     */
    object_detection.protos.Losses.HardExampleMinerOrBuilder getHardExampleMinerOrBuilder();

    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     */
    boolean hasSecondStageClassificationLoss();
    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     */
    object_detection.protos.Losses.ClassificationLoss getSecondStageClassificationLoss();
    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     */
    object_detection.protos.Losses.ClassificationLossOrBuilder getSecondStageClassificationLossOrBuilder();

    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
     */
    boolean hasInplaceBatchnormUpdate();
    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
     */
    boolean getInplaceBatchnormUpdate();

    /**
     * <pre>
     * Force the use of matrix multiplication based crop and resize instead of
     * standard tf.image.crop_and_resize while computing second stage input
     * feature maps.
     * </pre>
     *
     * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
     */
    boolean hasUseMatmulCropAndResize();
    /**
     * <pre>
     * Force the use of matrix multiplication based crop and resize instead of
     * standard tf.image.crop_and_resize while computing second stage input
     * feature maps.
     * </pre>
     *
     * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
     */
    boolean getUseMatmulCropAndResize();

    /**
     * <pre>
     * Normally, anchors generated for a given image size are pruned during
     * training if they lie outside the image window. Setting this option to true,
     * clips the anchors to be within the image instead of pruning.
     * </pre>
     *
     * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
     */
    boolean hasClipAnchorsToImage();
    /**
     * <pre>
     * Normally, anchors generated for a given image size are pruned during
     * training if they lie outside the image window. Setting this option to true,
     * clips the anchors to be within the image instead of pruning.
     * </pre>
     *
     * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
     */
    boolean getClipAnchorsToImage();

    /**
     * <pre>
     * After peforming matching between anchors and targets, in order to pull out
     * targets for training Faster R-CNN meta architecture we perform a gather
     * operation. This options specifies whether to use an alternate
     * implementation of tf.gather that is faster on TPUs.
     * </pre>
     *
     * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
     */
    boolean hasUseMatmulGatherInMatcher();
    /**
     * <pre>
     * After peforming matching between anchors and targets, in order to pull out
     * targets for training Faster R-CNN meta architecture we perform a gather
     * operation. This options specifies whether to use an alternate
     * implementation of tf.gather that is faster on TPUs.
     * </pre>
     *
     * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
     */
    boolean getUseMatmulGatherInMatcher();

    /**
     * <pre>
     * Whether to use the balanced positive negative sampler implementation with
     * static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
     */
    boolean hasUseStaticBalancedLabelSampler();
    /**
     * <pre>
     * Whether to use the balanced positive negative sampler implementation with
     * static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
     */
    boolean getUseStaticBalancedLabelSampler();
  }
  /**
   * <pre>
   * Configuration for Faster R-CNN models.
   * See meta_architectures/faster_rcnn_meta_arch.py and models/model_builder.py
   * Naming conventions:
   * Faster R-CNN models have two stages: a first stage region proposal network
   * (or RPN) and a second stage box classifier.  We thus use the prefixes
   * `first_stage_` and `second_stage_` to indicate the stage to which each
   * parameter pertains when relevant.
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.FasterRcnn}
   */
  public  static final class FasterRcnn extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.FasterRcnn)
      FasterRcnnOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use FasterRcnn.newBuilder() to construct.
    private FasterRcnn(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private FasterRcnn() {
      numberOfStages_ = 2;
      numClasses_ = 0;
      firstStageAtrousRate_ = 1;
      firstStageBoxPredictorKernelSize_ = 3;
      firstStageBoxPredictorDepth_ = 512;
      firstStageMinibatchSize_ = 256;
      firstStagePositiveBalanceFraction_ = 0.5F;
      firstStageNmsScoreThreshold_ = 0F;
      firstStageNmsIouThreshold_ = 0.7F;
      firstStageMaxProposals_ = 300;
      firstStageLocalizationLossWeight_ = 1F;
      firstStageObjectnessLossWeight_ = 1F;
      initialCropSize_ = 0;
      maxpoolKernelSize_ = 0;
      maxpoolStride_ = 0;
      secondStageBatchSize_ = 64;
      secondStageBalanceFraction_ = 0.25F;
      secondStageLocalizationLossWeight_ = 1F;
      secondStageClassificationLossWeight_ = 1F;
      secondStageMaskPredictionLossWeight_ = 1F;
      inplaceBatchnormUpdate_ = false;
      useMatmulCropAndResize_ = false;
      clipAnchorsToImage_ = false;
      useMatmulGatherInMatcher_ = false;
      useStaticBalancedLabelSampler_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private FasterRcnn(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      int mutable_bitField1_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              numberOfStages_ = input.readInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000002;
              numClasses_ = input.readInt32();
              break;
            }
            case 34: {
              object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = imageResizer_.toBuilder();
              }
              imageResizer_ = input.readMessage(object_detection.protos.ImageResizerOuterClass.ImageResizer.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(imageResizer_);
                imageResizer_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 42: {
              object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) == 0x00000008)) {
                subBuilder = featureExtractor_.toBuilder();
              }
              featureExtractor_ = input.readMessage(object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(featureExtractor_);
                featureExtractor_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 50: {
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) == 0x00000010)) {
                subBuilder = firstStageAnchorGenerator_.toBuilder();
              }
              firstStageAnchorGenerator_ = input.readMessage(object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(firstStageAnchorGenerator_);
                firstStageAnchorGenerator_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 56: {
              bitField0_ |= 0x00000020;
              firstStageAtrousRate_ = input.readInt32();
              break;
            }
            case 66: {
              object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder subBuilder = null;
              if (((bitField0_ & 0x00000040) == 0x00000040)) {
                subBuilder = firstStageBoxPredictorConvHyperparams_.toBuilder();
              }
              firstStageBoxPredictorConvHyperparams_ = input.readMessage(object_detection.protos.HyperparamsOuterClass.Hyperparams.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(firstStageBoxPredictorConvHyperparams_);
                firstStageBoxPredictorConvHyperparams_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000040;
              break;
            }
            case 72: {
              bitField0_ |= 0x00000080;
              firstStageBoxPredictorKernelSize_ = input.readInt32();
              break;
            }
            case 80: {
              bitField0_ |= 0x00000100;
              firstStageBoxPredictorDepth_ = input.readInt32();
              break;
            }
            case 88: {
              bitField0_ |= 0x00000200;
              firstStageMinibatchSize_ = input.readInt32();
              break;
            }
            case 101: {
              bitField0_ |= 0x00000400;
              firstStagePositiveBalanceFraction_ = input.readFloat();
              break;
            }
            case 109: {
              bitField0_ |= 0x00000800;
              firstStageNmsScoreThreshold_ = input.readFloat();
              break;
            }
            case 117: {
              bitField0_ |= 0x00001000;
              firstStageNmsIouThreshold_ = input.readFloat();
              break;
            }
            case 120: {
              bitField0_ |= 0x00002000;
              firstStageMaxProposals_ = input.readInt32();
              break;
            }
            case 133: {
              bitField0_ |= 0x00004000;
              firstStageLocalizationLossWeight_ = input.readFloat();
              break;
            }
            case 141: {
              bitField0_ |= 0x00008000;
              firstStageObjectnessLossWeight_ = input.readFloat();
              break;
            }
            case 144: {
              bitField0_ |= 0x00010000;
              initialCropSize_ = input.readInt32();
              break;
            }
            case 152: {
              bitField0_ |= 0x00020000;
              maxpoolKernelSize_ = input.readInt32();
              break;
            }
            case 160: {
              bitField0_ |= 0x00040000;
              maxpoolStride_ = input.readInt32();
              break;
            }
            case 170: {
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder subBuilder = null;
              if (((bitField0_ & 0x00080000) == 0x00080000)) {
                subBuilder = secondStageBoxPredictor_.toBuilder();
              }
              secondStageBoxPredictor_ = input.readMessage(object_detection.protos.BoxPredictorOuterClass.BoxPredictor.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(secondStageBoxPredictor_);
                secondStageBoxPredictor_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00080000;
              break;
            }
            case 176: {
              bitField0_ |= 0x00100000;
              secondStageBatchSize_ = input.readInt32();
              break;
            }
            case 189: {
              bitField0_ |= 0x00200000;
              secondStageBalanceFraction_ = input.readFloat();
              break;
            }
            case 194: {
              object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder subBuilder = null;
              if (((bitField0_ & 0x00400000) == 0x00400000)) {
                subBuilder = secondStagePostProcessing_.toBuilder();
              }
              secondStagePostProcessing_ = input.readMessage(object_detection.protos.PostProcessingOuterClass.PostProcessing.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(secondStagePostProcessing_);
                secondStagePostProcessing_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00400000;
              break;
            }
            case 205: {
              bitField0_ |= 0x00800000;
              secondStageLocalizationLossWeight_ = input.readFloat();
              break;
            }
            case 213: {
              bitField0_ |= 0x01000000;
              secondStageClassificationLossWeight_ = input.readFloat();
              break;
            }
            case 221: {
              bitField0_ |= 0x02000000;
              secondStageMaskPredictionLossWeight_ = input.readFloat();
              break;
            }
            case 226: {
              object_detection.protos.Losses.HardExampleMiner.Builder subBuilder = null;
              if (((bitField0_ & 0x04000000) == 0x04000000)) {
                subBuilder = hardExampleMiner_.toBuilder();
              }
              hardExampleMiner_ = input.readMessage(object_detection.protos.Losses.HardExampleMiner.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(hardExampleMiner_);
                hardExampleMiner_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x04000000;
              break;
            }
            case 234: {
              object_detection.protos.Losses.ClassificationLoss.Builder subBuilder = null;
              if (((bitField0_ & 0x08000000) == 0x08000000)) {
                subBuilder = secondStageClassificationLoss_.toBuilder();
              }
              secondStageClassificationLoss_ = input.readMessage(object_detection.protos.Losses.ClassificationLoss.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(secondStageClassificationLoss_);
                secondStageClassificationLoss_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x08000000;
              break;
            }
            case 240: {
              bitField0_ |= 0x10000000;
              inplaceBatchnormUpdate_ = input.readBool();
              break;
            }
            case 248: {
              bitField0_ |= 0x20000000;
              useMatmulCropAndResize_ = input.readBool();
              break;
            }
            case 256: {
              bitField0_ |= 0x40000000;
              clipAnchorsToImage_ = input.readBool();
              break;
            }
            case 264: {
              bitField0_ |= 0x80000000;
              useMatmulGatherInMatcher_ = input.readBool();
              break;
            }
            case 272: {
              bitField1_ |= 0x00000001;
              useStaticBalancedLabelSampler_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnn_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnn_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.FasterRcnnOuterClass.FasterRcnn.class, object_detection.protos.FasterRcnnOuterClass.FasterRcnn.Builder.class);
    }

    private int bitField0_;
    private int bitField1_;
    public static final int NUMBER_OF_STAGES_FIELD_NUMBER = 1;
    private int numberOfStages_;
    /**
     * <pre>
     * Whether to construct only the Region Proposal Network (RPN).
     * </pre>
     *
     * <code>optional int32 number_of_stages = 1 [default = 2];</code>
     */
    public boolean hasNumberOfStages() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Whether to construct only the Region Proposal Network (RPN).
     * </pre>
     *
     * <code>optional int32 number_of_stages = 1 [default = 2];</code>
     */
    public int getNumberOfStages() {
      return numberOfStages_;
    }

    public static final int NUM_CLASSES_FIELD_NUMBER = 3;
    private int numClasses_;
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 3;</code>
     */
    public boolean hasNumClasses() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 3;</code>
     */
    public int getNumClasses() {
      return numClasses_;
    }

    public static final int IMAGE_RESIZER_FIELD_NUMBER = 4;
    private object_detection.protos.ImageResizerOuterClass.ImageResizer imageResizer_;
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     */
    public boolean hasImageResizer() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     */
    public object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer() {
      return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
    }
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     */
    public object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder() {
      return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
    }

    public static final int FEATURE_EXTRACTOR_FIELD_NUMBER = 5;
    private object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor featureExtractor_;
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     */
    public boolean hasFeatureExtractor() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     */
    public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getFeatureExtractor() {
      return featureExtractor_ == null ? object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance() : featureExtractor_;
    }
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     */
    public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder getFeatureExtractorOrBuilder() {
      return featureExtractor_ == null ? object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance() : featureExtractor_;
    }

    public static final int FIRST_STAGE_ANCHOR_GENERATOR_FIELD_NUMBER = 6;
    private object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator firstStageAnchorGenerator_;
    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     */
    public boolean hasFirstStageAnchorGenerator() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     */
    public object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator getFirstStageAnchorGenerator() {
      return firstStageAnchorGenerator_ == null ? object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : firstStageAnchorGenerator_;
    }
    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     */
    public object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder getFirstStageAnchorGeneratorOrBuilder() {
      return firstStageAnchorGenerator_ == null ? object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : firstStageAnchorGenerator_;
    }

    public static final int FIRST_STAGE_ATROUS_RATE_FIELD_NUMBER = 7;
    private int firstStageAtrousRate_;
    /**
     * <pre>
     * Atrous rate for the convolution op applied to the
     * `first_stage_features_to_crop` tensor to obtain box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
     */
    public boolean hasFirstStageAtrousRate() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * Atrous rate for the convolution op applied to the
     * `first_stage_features_to_crop` tensor to obtain box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
     */
    public int getFirstStageAtrousRate() {
      return firstStageAtrousRate_;
    }

    public static final int FIRST_STAGE_BOX_PREDICTOR_CONV_HYPERPARAMS_FIELD_NUMBER = 8;
    private object_detection.protos.HyperparamsOuterClass.Hyperparams firstStageBoxPredictorConvHyperparams_;
    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     */
    public boolean hasFirstStageBoxPredictorConvHyperparams() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     */
    public object_detection.protos.HyperparamsOuterClass.Hyperparams getFirstStageBoxPredictorConvHyperparams() {
      return firstStageBoxPredictorConvHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : firstStageBoxPredictorConvHyperparams_;
    }
    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     */
    public object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getFirstStageBoxPredictorConvHyperparamsOrBuilder() {
      return firstStageBoxPredictorConvHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : firstStageBoxPredictorConvHyperparams_;
    }

    public static final int FIRST_STAGE_BOX_PREDICTOR_KERNEL_SIZE_FIELD_NUMBER = 9;
    private int firstStageBoxPredictorKernelSize_;
    /**
     * <pre>
     * Kernel size to use for the convolution op just prior to RPN box
     * predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
     */
    public boolean hasFirstStageBoxPredictorKernelSize() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * Kernel size to use for the convolution op just prior to RPN box
     * predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
     */
    public int getFirstStageBoxPredictorKernelSize() {
      return firstStageBoxPredictorKernelSize_;
    }

    public static final int FIRST_STAGE_BOX_PREDICTOR_DEPTH_FIELD_NUMBER = 10;
    private int firstStageBoxPredictorDepth_;
    /**
     * <pre>
     * Output depth for the convolution op just prior to RPN box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
     */
    public boolean hasFirstStageBoxPredictorDepth() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <pre>
     * Output depth for the convolution op just prior to RPN box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
     */
    public int getFirstStageBoxPredictorDepth() {
      return firstStageBoxPredictorDepth_;
    }

    public static final int FIRST_STAGE_MINIBATCH_SIZE_FIELD_NUMBER = 11;
    private int firstStageMinibatchSize_;
    /**
     * <pre>
     * The batch size to use for computing the first stage objectness and
     * location losses.
     * </pre>
     *
     * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
     */
    public boolean hasFirstStageMinibatchSize() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <pre>
     * The batch size to use for computing the first stage objectness and
     * location losses.
     * </pre>
     *
     * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
     */
    public int getFirstStageMinibatchSize() {
      return firstStageMinibatchSize_;
    }

    public static final int FIRST_STAGE_POSITIVE_BALANCE_FRACTION_FIELD_NUMBER = 12;
    private float firstStagePositiveBalanceFraction_;
    /**
     * <pre>
     * Fraction of positive examples per image for the RPN.
     * </pre>
     *
     * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
     */
    public boolean hasFirstStagePositiveBalanceFraction() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <pre>
     * Fraction of positive examples per image for the RPN.
     * </pre>
     *
     * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
     */
    public float getFirstStagePositiveBalanceFraction() {
      return firstStagePositiveBalanceFraction_;
    }

    public static final int FIRST_STAGE_NMS_SCORE_THRESHOLD_FIELD_NUMBER = 13;
    private float firstStageNmsScoreThreshold_;
    /**
     * <pre>
     * Non max suppression score threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
     */
    public boolean hasFirstStageNmsScoreThreshold() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <pre>
     * Non max suppression score threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
     */
    public float getFirstStageNmsScoreThreshold() {
      return firstStageNmsScoreThreshold_;
    }

    public static final int FIRST_STAGE_NMS_IOU_THRESHOLD_FIELD_NUMBER = 14;
    private float firstStageNmsIouThreshold_;
    /**
     * <pre>
     * Non max suppression IOU threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
     */
    public boolean hasFirstStageNmsIouThreshold() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <pre>
     * Non max suppression IOU threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
     */
    public float getFirstStageNmsIouThreshold() {
      return firstStageNmsIouThreshold_;
    }

    public static final int FIRST_STAGE_MAX_PROPOSALS_FIELD_NUMBER = 15;
    private int firstStageMaxProposals_;
    /**
     * <pre>
     * Maximum number of RPN proposals retained after first stage postprocessing.
     * </pre>
     *
     * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
     */
    public boolean hasFirstStageMaxProposals() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <pre>
     * Maximum number of RPN proposals retained after first stage postprocessing.
     * </pre>
     *
     * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
     */
    public int getFirstStageMaxProposals() {
      return firstStageMaxProposals_;
    }

    public static final int FIRST_STAGE_LOCALIZATION_LOSS_WEIGHT_FIELD_NUMBER = 16;
    private float firstStageLocalizationLossWeight_;
    /**
     * <pre>
     * First stage RPN localization loss weight.
     * </pre>
     *
     * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
     */
    public boolean hasFirstStageLocalizationLossWeight() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <pre>
     * First stage RPN localization loss weight.
     * </pre>
     *
     * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
     */
    public float getFirstStageLocalizationLossWeight() {
      return firstStageLocalizationLossWeight_;
    }

    public static final int FIRST_STAGE_OBJECTNESS_LOSS_WEIGHT_FIELD_NUMBER = 17;
    private float firstStageObjectnessLossWeight_;
    /**
     * <pre>
     * First stage RPN objectness loss weight.
     * </pre>
     *
     * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
     */
    public boolean hasFirstStageObjectnessLossWeight() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <pre>
     * First stage RPN objectness loss weight.
     * </pre>
     *
     * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
     */
    public float getFirstStageObjectnessLossWeight() {
      return firstStageObjectnessLossWeight_;
    }

    public static final int INITIAL_CROP_SIZE_FIELD_NUMBER = 18;
    private int initialCropSize_;
    /**
     * <pre>
     * Output size (width and height are set to be the same) of the initial
     * bilinear interpolation based cropping during ROI pooling.
     * </pre>
     *
     * <code>optional int32 initial_crop_size = 18;</code>
     */
    public boolean hasInitialCropSize() {
      return ((bitField0_ & 0x00010000) == 0x00010000);
    }
    /**
     * <pre>
     * Output size (width and height are set to be the same) of the initial
     * bilinear interpolation based cropping during ROI pooling.
     * </pre>
     *
     * <code>optional int32 initial_crop_size = 18;</code>
     */
    public int getInitialCropSize() {
      return initialCropSize_;
    }

    public static final int MAXPOOL_KERNEL_SIZE_FIELD_NUMBER = 19;
    private int maxpoolKernelSize_;
    /**
     * <pre>
     * Kernel size of the max pool op on the cropped feature map during
     * ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_kernel_size = 19;</code>
     */
    public boolean hasMaxpoolKernelSize() {
      return ((bitField0_ & 0x00020000) == 0x00020000);
    }
    /**
     * <pre>
     * Kernel size of the max pool op on the cropped feature map during
     * ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_kernel_size = 19;</code>
     */
    public int getMaxpoolKernelSize() {
      return maxpoolKernelSize_;
    }

    public static final int MAXPOOL_STRIDE_FIELD_NUMBER = 20;
    private int maxpoolStride_;
    /**
     * <pre>
     * Stride of the max pool op on the cropped feature map during ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_stride = 20;</code>
     */
    public boolean hasMaxpoolStride() {
      return ((bitField0_ & 0x00040000) == 0x00040000);
    }
    /**
     * <pre>
     * Stride of the max pool op on the cropped feature map during ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_stride = 20;</code>
     */
    public int getMaxpoolStride() {
      return maxpoolStride_;
    }

    public static final int SECOND_STAGE_BOX_PREDICTOR_FIELD_NUMBER = 21;
    private object_detection.protos.BoxPredictorOuterClass.BoxPredictor secondStageBoxPredictor_;
    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     */
    public boolean hasSecondStageBoxPredictor() {
      return ((bitField0_ & 0x00080000) == 0x00080000);
    }
    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     */
    public object_detection.protos.BoxPredictorOuterClass.BoxPredictor getSecondStageBoxPredictor() {
      return secondStageBoxPredictor_ == null ? object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : secondStageBoxPredictor_;
    }
    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     */
    public object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder getSecondStageBoxPredictorOrBuilder() {
      return secondStageBoxPredictor_ == null ? object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : secondStageBoxPredictor_;
    }

    public static final int SECOND_STAGE_BATCH_SIZE_FIELD_NUMBER = 22;
    private int secondStageBatchSize_;
    /**
     * <pre>
     * The batch size per image used for computing the classification and refined
     * location loss of the box classifier.
     * Note that this field is ignored if `hard_example_miner` is configured.
     * </pre>
     *
     * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
     */
    public boolean hasSecondStageBatchSize() {
      return ((bitField0_ & 0x00100000) == 0x00100000);
    }
    /**
     * <pre>
     * The batch size per image used for computing the classification and refined
     * location loss of the box classifier.
     * Note that this field is ignored if `hard_example_miner` is configured.
     * </pre>
     *
     * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
     */
    public int getSecondStageBatchSize() {
      return secondStageBatchSize_;
    }

    public static final int SECOND_STAGE_BALANCE_FRACTION_FIELD_NUMBER = 23;
    private float secondStageBalanceFraction_;
    /**
     * <pre>
     * Fraction of positive examples to use per image for the box classifier.
     * </pre>
     *
     * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
     */
    public boolean hasSecondStageBalanceFraction() {
      return ((bitField0_ & 0x00200000) == 0x00200000);
    }
    /**
     * <pre>
     * Fraction of positive examples to use per image for the box classifier.
     * </pre>
     *
     * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
     */
    public float getSecondStageBalanceFraction() {
      return secondStageBalanceFraction_;
    }

    public static final int SECOND_STAGE_POST_PROCESSING_FIELD_NUMBER = 24;
    private object_detection.protos.PostProcessingOuterClass.PostProcessing secondStagePostProcessing_;
    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     */
    public boolean hasSecondStagePostProcessing() {
      return ((bitField0_ & 0x00400000) == 0x00400000);
    }
    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     */
    public object_detection.protos.PostProcessingOuterClass.PostProcessing getSecondStagePostProcessing() {
      return secondStagePostProcessing_ == null ? object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : secondStagePostProcessing_;
    }
    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     */
    public object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder getSecondStagePostProcessingOrBuilder() {
      return secondStagePostProcessing_ == null ? object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : secondStagePostProcessing_;
    }

    public static final int SECOND_STAGE_LOCALIZATION_LOSS_WEIGHT_FIELD_NUMBER = 25;
    private float secondStageLocalizationLossWeight_;
    /**
     * <pre>
     * Second stage refined localization loss weight.
     * </pre>
     *
     * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
     */
    public boolean hasSecondStageLocalizationLossWeight() {
      return ((bitField0_ & 0x00800000) == 0x00800000);
    }
    /**
     * <pre>
     * Second stage refined localization loss weight.
     * </pre>
     *
     * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
     */
    public float getSecondStageLocalizationLossWeight() {
      return secondStageLocalizationLossWeight_;
    }

    public static final int SECOND_STAGE_CLASSIFICATION_LOSS_WEIGHT_FIELD_NUMBER = 26;
    private float secondStageClassificationLossWeight_;
    /**
     * <pre>
     * Second stage classification loss weight
     * </pre>
     *
     * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
     */
    public boolean hasSecondStageClassificationLossWeight() {
      return ((bitField0_ & 0x01000000) == 0x01000000);
    }
    /**
     * <pre>
     * Second stage classification loss weight
     * </pre>
     *
     * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
     */
    public float getSecondStageClassificationLossWeight() {
      return secondStageClassificationLossWeight_;
    }

    public static final int SECOND_STAGE_MASK_PREDICTION_LOSS_WEIGHT_FIELD_NUMBER = 27;
    private float secondStageMaskPredictionLossWeight_;
    /**
     * <pre>
     * Second stage instance mask loss weight. Note that this is only applicable
     * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
     * predict instance masks.
     * </pre>
     *
     * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
     */
    public boolean hasSecondStageMaskPredictionLossWeight() {
      return ((bitField0_ & 0x02000000) == 0x02000000);
    }
    /**
     * <pre>
     * Second stage instance mask loss weight. Note that this is only applicable
     * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
     * predict instance masks.
     * </pre>
     *
     * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
     */
    public float getSecondStageMaskPredictionLossWeight() {
      return secondStageMaskPredictionLossWeight_;
    }

    public static final int HARD_EXAMPLE_MINER_FIELD_NUMBER = 28;
    private object_detection.protos.Losses.HardExampleMiner hardExampleMiner_;
    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     */
    public boolean hasHardExampleMiner() {
      return ((bitField0_ & 0x04000000) == 0x04000000);
    }
    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     */
    public object_detection.protos.Losses.HardExampleMiner getHardExampleMiner() {
      return hardExampleMiner_ == null ? object_detection.protos.Losses.HardExampleMiner.getDefaultInstance() : hardExampleMiner_;
    }
    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     */
    public object_detection.protos.Losses.HardExampleMinerOrBuilder getHardExampleMinerOrBuilder() {
      return hardExampleMiner_ == null ? object_detection.protos.Losses.HardExampleMiner.getDefaultInstance() : hardExampleMiner_;
    }

    public static final int SECOND_STAGE_CLASSIFICATION_LOSS_FIELD_NUMBER = 29;
    private object_detection.protos.Losses.ClassificationLoss secondStageClassificationLoss_;
    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     */
    public boolean hasSecondStageClassificationLoss() {
      return ((bitField0_ & 0x08000000) == 0x08000000);
    }
    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     */
    public object_detection.protos.Losses.ClassificationLoss getSecondStageClassificationLoss() {
      return secondStageClassificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : secondStageClassificationLoss_;
    }
    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     */
    public object_detection.protos.Losses.ClassificationLossOrBuilder getSecondStageClassificationLossOrBuilder() {
      return secondStageClassificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : secondStageClassificationLoss_;
    }

    public static final int INPLACE_BATCHNORM_UPDATE_FIELD_NUMBER = 30;
    private boolean inplaceBatchnormUpdate_;
    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
     */
    public boolean hasInplaceBatchnormUpdate() {
      return ((bitField0_ & 0x10000000) == 0x10000000);
    }
    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
     */
    public boolean getInplaceBatchnormUpdate() {
      return inplaceBatchnormUpdate_;
    }

    public static final int USE_MATMUL_CROP_AND_RESIZE_FIELD_NUMBER = 31;
    private boolean useMatmulCropAndResize_;
    /**
     * <pre>
     * Force the use of matrix multiplication based crop and resize instead of
     * standard tf.image.crop_and_resize while computing second stage input
     * feature maps.
     * </pre>
     *
     * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
     */
    public boolean hasUseMatmulCropAndResize() {
      return ((bitField0_ & 0x20000000) == 0x20000000);
    }
    /**
     * <pre>
     * Force the use of matrix multiplication based crop and resize instead of
     * standard tf.image.crop_and_resize while computing second stage input
     * feature maps.
     * </pre>
     *
     * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
     */
    public boolean getUseMatmulCropAndResize() {
      return useMatmulCropAndResize_;
    }

    public static final int CLIP_ANCHORS_TO_IMAGE_FIELD_NUMBER = 32;
    private boolean clipAnchorsToImage_;
    /**
     * <pre>
     * Normally, anchors generated for a given image size are pruned during
     * training if they lie outside the image window. Setting this option to true,
     * clips the anchors to be within the image instead of pruning.
     * </pre>
     *
     * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
     */
    public boolean hasClipAnchorsToImage() {
      return ((bitField0_ & 0x40000000) == 0x40000000);
    }
    /**
     * <pre>
     * Normally, anchors generated for a given image size are pruned during
     * training if they lie outside the image window. Setting this option to true,
     * clips the anchors to be within the image instead of pruning.
     * </pre>
     *
     * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
     */
    public boolean getClipAnchorsToImage() {
      return clipAnchorsToImage_;
    }

    public static final int USE_MATMUL_GATHER_IN_MATCHER_FIELD_NUMBER = 33;
    private boolean useMatmulGatherInMatcher_;
    /**
     * <pre>
     * After peforming matching between anchors and targets, in order to pull out
     * targets for training Faster R-CNN meta architecture we perform a gather
     * operation. This options specifies whether to use an alternate
     * implementation of tf.gather that is faster on TPUs.
     * </pre>
     *
     * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
     */
    public boolean hasUseMatmulGatherInMatcher() {
      return ((bitField0_ & 0x80000000) == 0x80000000);
    }
    /**
     * <pre>
     * After peforming matching between anchors and targets, in order to pull out
     * targets for training Faster R-CNN meta architecture we perform a gather
     * operation. This options specifies whether to use an alternate
     * implementation of tf.gather that is faster on TPUs.
     * </pre>
     *
     * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
     */
    public boolean getUseMatmulGatherInMatcher() {
      return useMatmulGatherInMatcher_;
    }

    public static final int USE_STATIC_BALANCED_LABEL_SAMPLER_FIELD_NUMBER = 34;
    private boolean useStaticBalancedLabelSampler_;
    /**
     * <pre>
     * Whether to use the balanced positive negative sampler implementation with
     * static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
     */
    public boolean hasUseStaticBalancedLabelSampler() {
      return ((bitField1_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Whether to use the balanced positive negative sampler implementation with
     * static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
     */
    public boolean getUseStaticBalancedLabelSampler() {
      return useStaticBalancedLabelSampler_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, numberOfStages_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(3, numClasses_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(4, getImageResizer());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(5, getFeatureExtractor());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(6, getFirstStageAnchorGenerator());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeInt32(7, firstStageAtrousRate_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeMessage(8, getFirstStageBoxPredictorConvHyperparams());
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeInt32(9, firstStageBoxPredictorKernelSize_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeInt32(10, firstStageBoxPredictorDepth_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeInt32(11, firstStageMinibatchSize_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeFloat(12, firstStagePositiveBalanceFraction_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeFloat(13, firstStageNmsScoreThreshold_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeFloat(14, firstStageNmsIouThreshold_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeInt32(15, firstStageMaxProposals_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        output.writeFloat(16, firstStageLocalizationLossWeight_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeFloat(17, firstStageObjectnessLossWeight_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeInt32(18, initialCropSize_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeInt32(19, maxpoolKernelSize_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeInt32(20, maxpoolStride_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        output.writeMessage(21, getSecondStageBoxPredictor());
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        output.writeInt32(22, secondStageBatchSize_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        output.writeFloat(23, secondStageBalanceFraction_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        output.writeMessage(24, getSecondStagePostProcessing());
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        output.writeFloat(25, secondStageLocalizationLossWeight_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        output.writeFloat(26, secondStageClassificationLossWeight_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        output.writeFloat(27, secondStageMaskPredictionLossWeight_);
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        output.writeMessage(28, getHardExampleMiner());
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        output.writeMessage(29, getSecondStageClassificationLoss());
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        output.writeBool(30, inplaceBatchnormUpdate_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        output.writeBool(31, useMatmulCropAndResize_);
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        output.writeBool(32, clipAnchorsToImage_);
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        output.writeBool(33, useMatmulGatherInMatcher_);
      }
      if (((bitField1_ & 0x00000001) == 0x00000001)) {
        output.writeBool(34, useStaticBalancedLabelSampler_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, numberOfStages_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, numClasses_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getImageResizer());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getFeatureExtractor());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getFirstStageAnchorGenerator());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, firstStageAtrousRate_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getFirstStageBoxPredictorConvHyperparams());
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, firstStageBoxPredictorKernelSize_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(10, firstStageBoxPredictorDepth_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(11, firstStageMinibatchSize_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(12, firstStagePositiveBalanceFraction_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(13, firstStageNmsScoreThreshold_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(14, firstStageNmsIouThreshold_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(15, firstStageMaxProposals_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(16, firstStageLocalizationLossWeight_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(17, firstStageObjectnessLossWeight_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(18, initialCropSize_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(19, maxpoolKernelSize_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(20, maxpoolStride_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(21, getSecondStageBoxPredictor());
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(22, secondStageBatchSize_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(23, secondStageBalanceFraction_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(24, getSecondStagePostProcessing());
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(25, secondStageLocalizationLossWeight_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(26, secondStageClassificationLossWeight_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(27, secondStageMaskPredictionLossWeight_);
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(28, getHardExampleMiner());
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(29, getSecondStageClassificationLoss());
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(30, inplaceBatchnormUpdate_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(31, useMatmulCropAndResize_);
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(32, clipAnchorsToImage_);
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(33, useMatmulGatherInMatcher_);
      }
      if (((bitField1_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(34, useStaticBalancedLabelSampler_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.FasterRcnnOuterClass.FasterRcnn)) {
        return super.equals(obj);
      }
      object_detection.protos.FasterRcnnOuterClass.FasterRcnn other = (object_detection.protos.FasterRcnnOuterClass.FasterRcnn) obj;

      boolean result = true;
      result = result && (hasNumberOfStages() == other.hasNumberOfStages());
      if (hasNumberOfStages()) {
        result = result && (getNumberOfStages()
            == other.getNumberOfStages());
      }
      result = result && (hasNumClasses() == other.hasNumClasses());
      if (hasNumClasses()) {
        result = result && (getNumClasses()
            == other.getNumClasses());
      }
      result = result && (hasImageResizer() == other.hasImageResizer());
      if (hasImageResizer()) {
        result = result && getImageResizer()
            .equals(other.getImageResizer());
      }
      result = result && (hasFeatureExtractor() == other.hasFeatureExtractor());
      if (hasFeatureExtractor()) {
        result = result && getFeatureExtractor()
            .equals(other.getFeatureExtractor());
      }
      result = result && (hasFirstStageAnchorGenerator() == other.hasFirstStageAnchorGenerator());
      if (hasFirstStageAnchorGenerator()) {
        result = result && getFirstStageAnchorGenerator()
            .equals(other.getFirstStageAnchorGenerator());
      }
      result = result && (hasFirstStageAtrousRate() == other.hasFirstStageAtrousRate());
      if (hasFirstStageAtrousRate()) {
        result = result && (getFirstStageAtrousRate()
            == other.getFirstStageAtrousRate());
      }
      result = result && (hasFirstStageBoxPredictorConvHyperparams() == other.hasFirstStageBoxPredictorConvHyperparams());
      if (hasFirstStageBoxPredictorConvHyperparams()) {
        result = result && getFirstStageBoxPredictorConvHyperparams()
            .equals(other.getFirstStageBoxPredictorConvHyperparams());
      }
      result = result && (hasFirstStageBoxPredictorKernelSize() == other.hasFirstStageBoxPredictorKernelSize());
      if (hasFirstStageBoxPredictorKernelSize()) {
        result = result && (getFirstStageBoxPredictorKernelSize()
            == other.getFirstStageBoxPredictorKernelSize());
      }
      result = result && (hasFirstStageBoxPredictorDepth() == other.hasFirstStageBoxPredictorDepth());
      if (hasFirstStageBoxPredictorDepth()) {
        result = result && (getFirstStageBoxPredictorDepth()
            == other.getFirstStageBoxPredictorDepth());
      }
      result = result && (hasFirstStageMinibatchSize() == other.hasFirstStageMinibatchSize());
      if (hasFirstStageMinibatchSize()) {
        result = result && (getFirstStageMinibatchSize()
            == other.getFirstStageMinibatchSize());
      }
      result = result && (hasFirstStagePositiveBalanceFraction() == other.hasFirstStagePositiveBalanceFraction());
      if (hasFirstStagePositiveBalanceFraction()) {
        result = result && (
            java.lang.Float.floatToIntBits(getFirstStagePositiveBalanceFraction())
            == java.lang.Float.floatToIntBits(
                other.getFirstStagePositiveBalanceFraction()));
      }
      result = result && (hasFirstStageNmsScoreThreshold() == other.hasFirstStageNmsScoreThreshold());
      if (hasFirstStageNmsScoreThreshold()) {
        result = result && (
            java.lang.Float.floatToIntBits(getFirstStageNmsScoreThreshold())
            == java.lang.Float.floatToIntBits(
                other.getFirstStageNmsScoreThreshold()));
      }
      result = result && (hasFirstStageNmsIouThreshold() == other.hasFirstStageNmsIouThreshold());
      if (hasFirstStageNmsIouThreshold()) {
        result = result && (
            java.lang.Float.floatToIntBits(getFirstStageNmsIouThreshold())
            == java.lang.Float.floatToIntBits(
                other.getFirstStageNmsIouThreshold()));
      }
      result = result && (hasFirstStageMaxProposals() == other.hasFirstStageMaxProposals());
      if (hasFirstStageMaxProposals()) {
        result = result && (getFirstStageMaxProposals()
            == other.getFirstStageMaxProposals());
      }
      result = result && (hasFirstStageLocalizationLossWeight() == other.hasFirstStageLocalizationLossWeight());
      if (hasFirstStageLocalizationLossWeight()) {
        result = result && (
            java.lang.Float.floatToIntBits(getFirstStageLocalizationLossWeight())
            == java.lang.Float.floatToIntBits(
                other.getFirstStageLocalizationLossWeight()));
      }
      result = result && (hasFirstStageObjectnessLossWeight() == other.hasFirstStageObjectnessLossWeight());
      if (hasFirstStageObjectnessLossWeight()) {
        result = result && (
            java.lang.Float.floatToIntBits(getFirstStageObjectnessLossWeight())
            == java.lang.Float.floatToIntBits(
                other.getFirstStageObjectnessLossWeight()));
      }
      result = result && (hasInitialCropSize() == other.hasInitialCropSize());
      if (hasInitialCropSize()) {
        result = result && (getInitialCropSize()
            == other.getInitialCropSize());
      }
      result = result && (hasMaxpoolKernelSize() == other.hasMaxpoolKernelSize());
      if (hasMaxpoolKernelSize()) {
        result = result && (getMaxpoolKernelSize()
            == other.getMaxpoolKernelSize());
      }
      result = result && (hasMaxpoolStride() == other.hasMaxpoolStride());
      if (hasMaxpoolStride()) {
        result = result && (getMaxpoolStride()
            == other.getMaxpoolStride());
      }
      result = result && (hasSecondStageBoxPredictor() == other.hasSecondStageBoxPredictor());
      if (hasSecondStageBoxPredictor()) {
        result = result && getSecondStageBoxPredictor()
            .equals(other.getSecondStageBoxPredictor());
      }
      result = result && (hasSecondStageBatchSize() == other.hasSecondStageBatchSize());
      if (hasSecondStageBatchSize()) {
        result = result && (getSecondStageBatchSize()
            == other.getSecondStageBatchSize());
      }
      result = result && (hasSecondStageBalanceFraction() == other.hasSecondStageBalanceFraction());
      if (hasSecondStageBalanceFraction()) {
        result = result && (
            java.lang.Float.floatToIntBits(getSecondStageBalanceFraction())
            == java.lang.Float.floatToIntBits(
                other.getSecondStageBalanceFraction()));
      }
      result = result && (hasSecondStagePostProcessing() == other.hasSecondStagePostProcessing());
      if (hasSecondStagePostProcessing()) {
        result = result && getSecondStagePostProcessing()
            .equals(other.getSecondStagePostProcessing());
      }
      result = result && (hasSecondStageLocalizationLossWeight() == other.hasSecondStageLocalizationLossWeight());
      if (hasSecondStageLocalizationLossWeight()) {
        result = result && (
            java.lang.Float.floatToIntBits(getSecondStageLocalizationLossWeight())
            == java.lang.Float.floatToIntBits(
                other.getSecondStageLocalizationLossWeight()));
      }
      result = result && (hasSecondStageClassificationLossWeight() == other.hasSecondStageClassificationLossWeight());
      if (hasSecondStageClassificationLossWeight()) {
        result = result && (
            java.lang.Float.floatToIntBits(getSecondStageClassificationLossWeight())
            == java.lang.Float.floatToIntBits(
                other.getSecondStageClassificationLossWeight()));
      }
      result = result && (hasSecondStageMaskPredictionLossWeight() == other.hasSecondStageMaskPredictionLossWeight());
      if (hasSecondStageMaskPredictionLossWeight()) {
        result = result && (
            java.lang.Float.floatToIntBits(getSecondStageMaskPredictionLossWeight())
            == java.lang.Float.floatToIntBits(
                other.getSecondStageMaskPredictionLossWeight()));
      }
      result = result && (hasHardExampleMiner() == other.hasHardExampleMiner());
      if (hasHardExampleMiner()) {
        result = result && getHardExampleMiner()
            .equals(other.getHardExampleMiner());
      }
      result = result && (hasSecondStageClassificationLoss() == other.hasSecondStageClassificationLoss());
      if (hasSecondStageClassificationLoss()) {
        result = result && getSecondStageClassificationLoss()
            .equals(other.getSecondStageClassificationLoss());
      }
      result = result && (hasInplaceBatchnormUpdate() == other.hasInplaceBatchnormUpdate());
      if (hasInplaceBatchnormUpdate()) {
        result = result && (getInplaceBatchnormUpdate()
            == other.getInplaceBatchnormUpdate());
      }
      result = result && (hasUseMatmulCropAndResize() == other.hasUseMatmulCropAndResize());
      if (hasUseMatmulCropAndResize()) {
        result = result && (getUseMatmulCropAndResize()
            == other.getUseMatmulCropAndResize());
      }
      result = result && (hasClipAnchorsToImage() == other.hasClipAnchorsToImage());
      if (hasClipAnchorsToImage()) {
        result = result && (getClipAnchorsToImage()
            == other.getClipAnchorsToImage());
      }
      result = result && (hasUseMatmulGatherInMatcher() == other.hasUseMatmulGatherInMatcher());
      if (hasUseMatmulGatherInMatcher()) {
        result = result && (getUseMatmulGatherInMatcher()
            == other.getUseMatmulGatherInMatcher());
      }
      result = result && (hasUseStaticBalancedLabelSampler() == other.hasUseStaticBalancedLabelSampler());
      if (hasUseStaticBalancedLabelSampler()) {
        result = result && (getUseStaticBalancedLabelSampler()
            == other.getUseStaticBalancedLabelSampler());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNumberOfStages()) {
        hash = (37 * hash) + NUMBER_OF_STAGES_FIELD_NUMBER;
        hash = (53 * hash) + getNumberOfStages();
      }
      if (hasNumClasses()) {
        hash = (37 * hash) + NUM_CLASSES_FIELD_NUMBER;
        hash = (53 * hash) + getNumClasses();
      }
      if (hasImageResizer()) {
        hash = (37 * hash) + IMAGE_RESIZER_FIELD_NUMBER;
        hash = (53 * hash) + getImageResizer().hashCode();
      }
      if (hasFeatureExtractor()) {
        hash = (37 * hash) + FEATURE_EXTRACTOR_FIELD_NUMBER;
        hash = (53 * hash) + getFeatureExtractor().hashCode();
      }
      if (hasFirstStageAnchorGenerator()) {
        hash = (37 * hash) + FIRST_STAGE_ANCHOR_GENERATOR_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageAnchorGenerator().hashCode();
      }
      if (hasFirstStageAtrousRate()) {
        hash = (37 * hash) + FIRST_STAGE_ATROUS_RATE_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageAtrousRate();
      }
      if (hasFirstStageBoxPredictorConvHyperparams()) {
        hash = (37 * hash) + FIRST_STAGE_BOX_PREDICTOR_CONV_HYPERPARAMS_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageBoxPredictorConvHyperparams().hashCode();
      }
      if (hasFirstStageBoxPredictorKernelSize()) {
        hash = (37 * hash) + FIRST_STAGE_BOX_PREDICTOR_KERNEL_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageBoxPredictorKernelSize();
      }
      if (hasFirstStageBoxPredictorDepth()) {
        hash = (37 * hash) + FIRST_STAGE_BOX_PREDICTOR_DEPTH_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageBoxPredictorDepth();
      }
      if (hasFirstStageMinibatchSize()) {
        hash = (37 * hash) + FIRST_STAGE_MINIBATCH_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageMinibatchSize();
      }
      if (hasFirstStagePositiveBalanceFraction()) {
        hash = (37 * hash) + FIRST_STAGE_POSITIVE_BALANCE_FRACTION_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFirstStagePositiveBalanceFraction());
      }
      if (hasFirstStageNmsScoreThreshold()) {
        hash = (37 * hash) + FIRST_STAGE_NMS_SCORE_THRESHOLD_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFirstStageNmsScoreThreshold());
      }
      if (hasFirstStageNmsIouThreshold()) {
        hash = (37 * hash) + FIRST_STAGE_NMS_IOU_THRESHOLD_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFirstStageNmsIouThreshold());
      }
      if (hasFirstStageMaxProposals()) {
        hash = (37 * hash) + FIRST_STAGE_MAX_PROPOSALS_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageMaxProposals();
      }
      if (hasFirstStageLocalizationLossWeight()) {
        hash = (37 * hash) + FIRST_STAGE_LOCALIZATION_LOSS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFirstStageLocalizationLossWeight());
      }
      if (hasFirstStageObjectnessLossWeight()) {
        hash = (37 * hash) + FIRST_STAGE_OBJECTNESS_LOSS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFirstStageObjectnessLossWeight());
      }
      if (hasInitialCropSize()) {
        hash = (37 * hash) + INITIAL_CROP_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getInitialCropSize();
      }
      if (hasMaxpoolKernelSize()) {
        hash = (37 * hash) + MAXPOOL_KERNEL_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxpoolKernelSize();
      }
      if (hasMaxpoolStride()) {
        hash = (37 * hash) + MAXPOOL_STRIDE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxpoolStride();
      }
      if (hasSecondStageBoxPredictor()) {
        hash = (37 * hash) + SECOND_STAGE_BOX_PREDICTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSecondStageBoxPredictor().hashCode();
      }
      if (hasSecondStageBatchSize()) {
        hash = (37 * hash) + SECOND_STAGE_BATCH_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getSecondStageBatchSize();
      }
      if (hasSecondStageBalanceFraction()) {
        hash = (37 * hash) + SECOND_STAGE_BALANCE_FRACTION_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getSecondStageBalanceFraction());
      }
      if (hasSecondStagePostProcessing()) {
        hash = (37 * hash) + SECOND_STAGE_POST_PROCESSING_FIELD_NUMBER;
        hash = (53 * hash) + getSecondStagePostProcessing().hashCode();
      }
      if (hasSecondStageLocalizationLossWeight()) {
        hash = (37 * hash) + SECOND_STAGE_LOCALIZATION_LOSS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getSecondStageLocalizationLossWeight());
      }
      if (hasSecondStageClassificationLossWeight()) {
        hash = (37 * hash) + SECOND_STAGE_CLASSIFICATION_LOSS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getSecondStageClassificationLossWeight());
      }
      if (hasSecondStageMaskPredictionLossWeight()) {
        hash = (37 * hash) + SECOND_STAGE_MASK_PREDICTION_LOSS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getSecondStageMaskPredictionLossWeight());
      }
      if (hasHardExampleMiner()) {
        hash = (37 * hash) + HARD_EXAMPLE_MINER_FIELD_NUMBER;
        hash = (53 * hash) + getHardExampleMiner().hashCode();
      }
      if (hasSecondStageClassificationLoss()) {
        hash = (37 * hash) + SECOND_STAGE_CLASSIFICATION_LOSS_FIELD_NUMBER;
        hash = (53 * hash) + getSecondStageClassificationLoss().hashCode();
      }
      if (hasInplaceBatchnormUpdate()) {
        hash = (37 * hash) + INPLACE_BATCHNORM_UPDATE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getInplaceBatchnormUpdate());
      }
      if (hasUseMatmulCropAndResize()) {
        hash = (37 * hash) + USE_MATMUL_CROP_AND_RESIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseMatmulCropAndResize());
      }
      if (hasClipAnchorsToImage()) {
        hash = (37 * hash) + CLIP_ANCHORS_TO_IMAGE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getClipAnchorsToImage());
      }
      if (hasUseMatmulGatherInMatcher()) {
        hash = (37 * hash) + USE_MATMUL_GATHER_IN_MATCHER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseMatmulGatherInMatcher());
      }
      if (hasUseStaticBalancedLabelSampler()) {
        hash = (37 * hash) + USE_STATIC_BALANCED_LABEL_SAMPLER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseStaticBalancedLabelSampler());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.FasterRcnnOuterClass.FasterRcnn prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Configuration for Faster R-CNN models.
     * See meta_architectures/faster_rcnn_meta_arch.py and models/model_builder.py
     * Naming conventions:
     * Faster R-CNN models have two stages: a first stage region proposal network
     * (or RPN) and a second stage box classifier.  We thus use the prefixes
     * `first_stage_` and `second_stage_` to indicate the stage to which each
     * parameter pertains when relevant.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.FasterRcnn}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.FasterRcnn)
        object_detection.protos.FasterRcnnOuterClass.FasterRcnnOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnn_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnn_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.FasterRcnnOuterClass.FasterRcnn.class, object_detection.protos.FasterRcnnOuterClass.FasterRcnn.Builder.class);
      }

      // Construct using object_detection.protos.FasterRcnnOuterClass.FasterRcnn.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getImageResizerFieldBuilder();
          getFeatureExtractorFieldBuilder();
          getFirstStageAnchorGeneratorFieldBuilder();
          getFirstStageBoxPredictorConvHyperparamsFieldBuilder();
          getSecondStageBoxPredictorFieldBuilder();
          getSecondStagePostProcessingFieldBuilder();
          getHardExampleMinerFieldBuilder();
          getSecondStageClassificationLossFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        numberOfStages_ = 2;
        bitField0_ = (bitField0_ & ~0x00000001);
        numClasses_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        if (imageResizerBuilder_ == null) {
          imageResizer_ = null;
        } else {
          imageResizerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = null;
        } else {
          featureExtractorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        if (firstStageAnchorGeneratorBuilder_ == null) {
          firstStageAnchorGenerator_ = null;
        } else {
          firstStageAnchorGeneratorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        firstStageAtrousRate_ = 1;
        bitField0_ = (bitField0_ & ~0x00000020);
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          firstStageBoxPredictorConvHyperparams_ = null;
        } else {
          firstStageBoxPredictorConvHyperparamsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        firstStageBoxPredictorKernelSize_ = 3;
        bitField0_ = (bitField0_ & ~0x00000080);
        firstStageBoxPredictorDepth_ = 512;
        bitField0_ = (bitField0_ & ~0x00000100);
        firstStageMinibatchSize_ = 256;
        bitField0_ = (bitField0_ & ~0x00000200);
        firstStagePositiveBalanceFraction_ = 0.5F;
        bitField0_ = (bitField0_ & ~0x00000400);
        firstStageNmsScoreThreshold_ = 0F;
        bitField0_ = (bitField0_ & ~0x00000800);
        firstStageNmsIouThreshold_ = 0.7F;
        bitField0_ = (bitField0_ & ~0x00001000);
        firstStageMaxProposals_ = 300;
        bitField0_ = (bitField0_ & ~0x00002000);
        firstStageLocalizationLossWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x00004000);
        firstStageObjectnessLossWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x00008000);
        initialCropSize_ = 0;
        bitField0_ = (bitField0_ & ~0x00010000);
        maxpoolKernelSize_ = 0;
        bitField0_ = (bitField0_ & ~0x00020000);
        maxpoolStride_ = 0;
        bitField0_ = (bitField0_ & ~0x00040000);
        if (secondStageBoxPredictorBuilder_ == null) {
          secondStageBoxPredictor_ = null;
        } else {
          secondStageBoxPredictorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00080000);
        secondStageBatchSize_ = 64;
        bitField0_ = (bitField0_ & ~0x00100000);
        secondStageBalanceFraction_ = 0.25F;
        bitField0_ = (bitField0_ & ~0x00200000);
        if (secondStagePostProcessingBuilder_ == null) {
          secondStagePostProcessing_ = null;
        } else {
          secondStagePostProcessingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00400000);
        secondStageLocalizationLossWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x00800000);
        secondStageClassificationLossWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x01000000);
        secondStageMaskPredictionLossWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x02000000);
        if (hardExampleMinerBuilder_ == null) {
          hardExampleMiner_ = null;
        } else {
          hardExampleMinerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x04000000);
        if (secondStageClassificationLossBuilder_ == null) {
          secondStageClassificationLoss_ = null;
        } else {
          secondStageClassificationLossBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x08000000);
        inplaceBatchnormUpdate_ = false;
        bitField0_ = (bitField0_ & ~0x10000000);
        useMatmulCropAndResize_ = false;
        bitField0_ = (bitField0_ & ~0x20000000);
        clipAnchorsToImage_ = false;
        bitField0_ = (bitField0_ & ~0x40000000);
        useMatmulGatherInMatcher_ = false;
        bitField0_ = (bitField0_ & ~0x80000000);
        useStaticBalancedLabelSampler_ = false;
        bitField1_ = (bitField1_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnn_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnn getDefaultInstanceForType() {
        return object_detection.protos.FasterRcnnOuterClass.FasterRcnn.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnn build() {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnn result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnn buildPartial() {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnn result = new object_detection.protos.FasterRcnnOuterClass.FasterRcnn(this);
        int from_bitField0_ = bitField0_;
        int from_bitField1_ = bitField1_;
        int to_bitField0_ = 0;
        int to_bitField1_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.numberOfStages_ = numberOfStages_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.numClasses_ = numClasses_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (imageResizerBuilder_ == null) {
          result.imageResizer_ = imageResizer_;
        } else {
          result.imageResizer_ = imageResizerBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        if (featureExtractorBuilder_ == null) {
          result.featureExtractor_ = featureExtractor_;
        } else {
          result.featureExtractor_ = featureExtractorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        if (firstStageAnchorGeneratorBuilder_ == null) {
          result.firstStageAnchorGenerator_ = firstStageAnchorGenerator_;
        } else {
          result.firstStageAnchorGenerator_ = firstStageAnchorGeneratorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.firstStageAtrousRate_ = firstStageAtrousRate_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          result.firstStageBoxPredictorConvHyperparams_ = firstStageBoxPredictorConvHyperparams_;
        } else {
          result.firstStageBoxPredictorConvHyperparams_ = firstStageBoxPredictorConvHyperparamsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.firstStageBoxPredictorKernelSize_ = firstStageBoxPredictorKernelSize_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.firstStageBoxPredictorDepth_ = firstStageBoxPredictorDepth_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000200;
        }
        result.firstStageMinibatchSize_ = firstStageMinibatchSize_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000400;
        }
        result.firstStagePositiveBalanceFraction_ = firstStagePositiveBalanceFraction_;
        if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
          to_bitField0_ |= 0x00000800;
        }
        result.firstStageNmsScoreThreshold_ = firstStageNmsScoreThreshold_;
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00001000;
        }
        result.firstStageNmsIouThreshold_ = firstStageNmsIouThreshold_;
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00002000;
        }
        result.firstStageMaxProposals_ = firstStageMaxProposals_;
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00004000;
        }
        result.firstStageLocalizationLossWeight_ = firstStageLocalizationLossWeight_;
        if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
          to_bitField0_ |= 0x00008000;
        }
        result.firstStageObjectnessLossWeight_ = firstStageObjectnessLossWeight_;
        if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
          to_bitField0_ |= 0x00010000;
        }
        result.initialCropSize_ = initialCropSize_;
        if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
          to_bitField0_ |= 0x00020000;
        }
        result.maxpoolKernelSize_ = maxpoolKernelSize_;
        if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
          to_bitField0_ |= 0x00040000;
        }
        result.maxpoolStride_ = maxpoolStride_;
        if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
          to_bitField0_ |= 0x00080000;
        }
        if (secondStageBoxPredictorBuilder_ == null) {
          result.secondStageBoxPredictor_ = secondStageBoxPredictor_;
        } else {
          result.secondStageBoxPredictor_ = secondStageBoxPredictorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
          to_bitField0_ |= 0x00100000;
        }
        result.secondStageBatchSize_ = secondStageBatchSize_;
        if (((from_bitField0_ & 0x00200000) == 0x00200000)) {
          to_bitField0_ |= 0x00200000;
        }
        result.secondStageBalanceFraction_ = secondStageBalanceFraction_;
        if (((from_bitField0_ & 0x00400000) == 0x00400000)) {
          to_bitField0_ |= 0x00400000;
        }
        if (secondStagePostProcessingBuilder_ == null) {
          result.secondStagePostProcessing_ = secondStagePostProcessing_;
        } else {
          result.secondStagePostProcessing_ = secondStagePostProcessingBuilder_.build();
        }
        if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
          to_bitField0_ |= 0x00800000;
        }
        result.secondStageLocalizationLossWeight_ = secondStageLocalizationLossWeight_;
        if (((from_bitField0_ & 0x01000000) == 0x01000000)) {
          to_bitField0_ |= 0x01000000;
        }
        result.secondStageClassificationLossWeight_ = secondStageClassificationLossWeight_;
        if (((from_bitField0_ & 0x02000000) == 0x02000000)) {
          to_bitField0_ |= 0x02000000;
        }
        result.secondStageMaskPredictionLossWeight_ = secondStageMaskPredictionLossWeight_;
        if (((from_bitField0_ & 0x04000000) == 0x04000000)) {
          to_bitField0_ |= 0x04000000;
        }
        if (hardExampleMinerBuilder_ == null) {
          result.hardExampleMiner_ = hardExampleMiner_;
        } else {
          result.hardExampleMiner_ = hardExampleMinerBuilder_.build();
        }
        if (((from_bitField0_ & 0x08000000) == 0x08000000)) {
          to_bitField0_ |= 0x08000000;
        }
        if (secondStageClassificationLossBuilder_ == null) {
          result.secondStageClassificationLoss_ = secondStageClassificationLoss_;
        } else {
          result.secondStageClassificationLoss_ = secondStageClassificationLossBuilder_.build();
        }
        if (((from_bitField0_ & 0x10000000) == 0x10000000)) {
          to_bitField0_ |= 0x10000000;
        }
        result.inplaceBatchnormUpdate_ = inplaceBatchnormUpdate_;
        if (((from_bitField0_ & 0x20000000) == 0x20000000)) {
          to_bitField0_ |= 0x20000000;
        }
        result.useMatmulCropAndResize_ = useMatmulCropAndResize_;
        if (((from_bitField0_ & 0x40000000) == 0x40000000)) {
          to_bitField0_ |= 0x40000000;
        }
        result.clipAnchorsToImage_ = clipAnchorsToImage_;
        if (((from_bitField0_ & 0x80000000) == 0x80000000)) {
          to_bitField0_ |= 0x80000000;
        }
        result.useMatmulGatherInMatcher_ = useMatmulGatherInMatcher_;
        if (((from_bitField1_ & 0x00000001) == 0x00000001)) {
          to_bitField1_ |= 0x00000001;
        }
        result.useStaticBalancedLabelSampler_ = useStaticBalancedLabelSampler_;
        result.bitField0_ = to_bitField0_;
        result.bitField1_ = to_bitField1_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.FasterRcnnOuterClass.FasterRcnn) {
          return mergeFrom((object_detection.protos.FasterRcnnOuterClass.FasterRcnn)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.FasterRcnnOuterClass.FasterRcnn other) {
        if (other == object_detection.protos.FasterRcnnOuterClass.FasterRcnn.getDefaultInstance()) return this;
        if (other.hasNumberOfStages()) {
          setNumberOfStages(other.getNumberOfStages());
        }
        if (other.hasNumClasses()) {
          setNumClasses(other.getNumClasses());
        }
        if (other.hasImageResizer()) {
          mergeImageResizer(other.getImageResizer());
        }
        if (other.hasFeatureExtractor()) {
          mergeFeatureExtractor(other.getFeatureExtractor());
        }
        if (other.hasFirstStageAnchorGenerator()) {
          mergeFirstStageAnchorGenerator(other.getFirstStageAnchorGenerator());
        }
        if (other.hasFirstStageAtrousRate()) {
          setFirstStageAtrousRate(other.getFirstStageAtrousRate());
        }
        if (other.hasFirstStageBoxPredictorConvHyperparams()) {
          mergeFirstStageBoxPredictorConvHyperparams(other.getFirstStageBoxPredictorConvHyperparams());
        }
        if (other.hasFirstStageBoxPredictorKernelSize()) {
          setFirstStageBoxPredictorKernelSize(other.getFirstStageBoxPredictorKernelSize());
        }
        if (other.hasFirstStageBoxPredictorDepth()) {
          setFirstStageBoxPredictorDepth(other.getFirstStageBoxPredictorDepth());
        }
        if (other.hasFirstStageMinibatchSize()) {
          setFirstStageMinibatchSize(other.getFirstStageMinibatchSize());
        }
        if (other.hasFirstStagePositiveBalanceFraction()) {
          setFirstStagePositiveBalanceFraction(other.getFirstStagePositiveBalanceFraction());
        }
        if (other.hasFirstStageNmsScoreThreshold()) {
          setFirstStageNmsScoreThreshold(other.getFirstStageNmsScoreThreshold());
        }
        if (other.hasFirstStageNmsIouThreshold()) {
          setFirstStageNmsIouThreshold(other.getFirstStageNmsIouThreshold());
        }
        if (other.hasFirstStageMaxProposals()) {
          setFirstStageMaxProposals(other.getFirstStageMaxProposals());
        }
        if (other.hasFirstStageLocalizationLossWeight()) {
          setFirstStageLocalizationLossWeight(other.getFirstStageLocalizationLossWeight());
        }
        if (other.hasFirstStageObjectnessLossWeight()) {
          setFirstStageObjectnessLossWeight(other.getFirstStageObjectnessLossWeight());
        }
        if (other.hasInitialCropSize()) {
          setInitialCropSize(other.getInitialCropSize());
        }
        if (other.hasMaxpoolKernelSize()) {
          setMaxpoolKernelSize(other.getMaxpoolKernelSize());
        }
        if (other.hasMaxpoolStride()) {
          setMaxpoolStride(other.getMaxpoolStride());
        }
        if (other.hasSecondStageBoxPredictor()) {
          mergeSecondStageBoxPredictor(other.getSecondStageBoxPredictor());
        }
        if (other.hasSecondStageBatchSize()) {
          setSecondStageBatchSize(other.getSecondStageBatchSize());
        }
        if (other.hasSecondStageBalanceFraction()) {
          setSecondStageBalanceFraction(other.getSecondStageBalanceFraction());
        }
        if (other.hasSecondStagePostProcessing()) {
          mergeSecondStagePostProcessing(other.getSecondStagePostProcessing());
        }
        if (other.hasSecondStageLocalizationLossWeight()) {
          setSecondStageLocalizationLossWeight(other.getSecondStageLocalizationLossWeight());
        }
        if (other.hasSecondStageClassificationLossWeight()) {
          setSecondStageClassificationLossWeight(other.getSecondStageClassificationLossWeight());
        }
        if (other.hasSecondStageMaskPredictionLossWeight()) {
          setSecondStageMaskPredictionLossWeight(other.getSecondStageMaskPredictionLossWeight());
        }
        if (other.hasHardExampleMiner()) {
          mergeHardExampleMiner(other.getHardExampleMiner());
        }
        if (other.hasSecondStageClassificationLoss()) {
          mergeSecondStageClassificationLoss(other.getSecondStageClassificationLoss());
        }
        if (other.hasInplaceBatchnormUpdate()) {
          setInplaceBatchnormUpdate(other.getInplaceBatchnormUpdate());
        }
        if (other.hasUseMatmulCropAndResize()) {
          setUseMatmulCropAndResize(other.getUseMatmulCropAndResize());
        }
        if (other.hasClipAnchorsToImage()) {
          setClipAnchorsToImage(other.getClipAnchorsToImage());
        }
        if (other.hasUseMatmulGatherInMatcher()) {
          setUseMatmulGatherInMatcher(other.getUseMatmulGatherInMatcher());
        }
        if (other.hasUseStaticBalancedLabelSampler()) {
          setUseStaticBalancedLabelSampler(other.getUseStaticBalancedLabelSampler());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnn parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.FasterRcnnOuterClass.FasterRcnn) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;
      private int bitField1_;

      private int numberOfStages_ = 2;
      /**
       * <pre>
       * Whether to construct only the Region Proposal Network (RPN).
       * </pre>
       *
       * <code>optional int32 number_of_stages = 1 [default = 2];</code>
       */
      public boolean hasNumberOfStages() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Whether to construct only the Region Proposal Network (RPN).
       * </pre>
       *
       * <code>optional int32 number_of_stages = 1 [default = 2];</code>
       */
      public int getNumberOfStages() {
        return numberOfStages_;
      }
      /**
       * <pre>
       * Whether to construct only the Region Proposal Network (RPN).
       * </pre>
       *
       * <code>optional int32 number_of_stages = 1 [default = 2];</code>
       */
      public Builder setNumberOfStages(int value) {
        bitField0_ |= 0x00000001;
        numberOfStages_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to construct only the Region Proposal Network (RPN).
       * </pre>
       *
       * <code>optional int32 number_of_stages = 1 [default = 2];</code>
       */
      public Builder clearNumberOfStages() {
        bitField0_ = (bitField0_ & ~0x00000001);
        numberOfStages_ = 2;
        onChanged();
        return this;
      }

      private int numClasses_ ;
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 3;</code>
       */
      public boolean hasNumClasses() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 3;</code>
       */
      public int getNumClasses() {
        return numClasses_;
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 3;</code>
       */
      public Builder setNumClasses(int value) {
        bitField0_ |= 0x00000002;
        numClasses_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 3;</code>
       */
      public Builder clearNumClasses() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numClasses_ = 0;
        onChanged();
        return this;
      }

      private object_detection.protos.ImageResizerOuterClass.ImageResizer imageResizer_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder> imageResizerBuilder_;
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public boolean hasImageResizer() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer() {
        if (imageResizerBuilder_ == null) {
          return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
        } else {
          return imageResizerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public Builder setImageResizer(object_detection.protos.ImageResizerOuterClass.ImageResizer value) {
        if (imageResizerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          imageResizer_ = value;
          onChanged();
        } else {
          imageResizerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public Builder setImageResizer(
          object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder builderForValue) {
        if (imageResizerBuilder_ == null) {
          imageResizer_ = builderForValue.build();
          onChanged();
        } else {
          imageResizerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public Builder mergeImageResizer(object_detection.protos.ImageResizerOuterClass.ImageResizer value) {
        if (imageResizerBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              imageResizer_ != null &&
              imageResizer_ != object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance()) {
            imageResizer_ =
              object_detection.protos.ImageResizerOuterClass.ImageResizer.newBuilder(imageResizer_).mergeFrom(value).buildPartial();
          } else {
            imageResizer_ = value;
          }
          onChanged();
        } else {
          imageResizerBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public Builder clearImageResizer() {
        if (imageResizerBuilder_ == null) {
          imageResizer_ = null;
          onChanged();
        } else {
          imageResizerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder getImageResizerBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getImageResizerFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder() {
        if (imageResizerBuilder_ != null) {
          return imageResizerBuilder_.getMessageOrBuilder();
        } else {
          return imageResizer_ == null ?
              object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
        }
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder> 
          getImageResizerFieldBuilder() {
        if (imageResizerBuilder_ == null) {
          imageResizerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder>(
                  getImageResizer(),
                  getParentForChildren(),
                  isClean());
          imageResizer_ = null;
        }
        return imageResizerBuilder_;
      }

      private object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor featureExtractor_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder> featureExtractorBuilder_;
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public boolean hasFeatureExtractor() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getFeatureExtractor() {
        if (featureExtractorBuilder_ == null) {
          return featureExtractor_ == null ? object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance() : featureExtractor_;
        } else {
          return featureExtractorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public Builder setFeatureExtractor(object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor value) {
        if (featureExtractorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          featureExtractor_ = value;
          onChanged();
        } else {
          featureExtractorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public Builder setFeatureExtractor(
          object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder builderForValue) {
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = builderForValue.build();
          onChanged();
        } else {
          featureExtractorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public Builder mergeFeatureExtractor(object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor value) {
        if (featureExtractorBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008) &&
              featureExtractor_ != null &&
              featureExtractor_ != object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance()) {
            featureExtractor_ =
              object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.newBuilder(featureExtractor_).mergeFrom(value).buildPartial();
          } else {
            featureExtractor_ = value;
          }
          onChanged();
        } else {
          featureExtractorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public Builder clearFeatureExtractor() {
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = null;
          onChanged();
        } else {
          featureExtractorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder getFeatureExtractorBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getFeatureExtractorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder getFeatureExtractorOrBuilder() {
        if (featureExtractorBuilder_ != null) {
          return featureExtractorBuilder_.getMessageOrBuilder();
        } else {
          return featureExtractor_ == null ?
              object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance() : featureExtractor_;
        }
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder> 
          getFeatureExtractorFieldBuilder() {
        if (featureExtractorBuilder_ == null) {
          featureExtractorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder>(
                  getFeatureExtractor(),
                  getParentForChildren(),
                  isClean());
          featureExtractor_ = null;
        }
        return featureExtractorBuilder_;
      }

      private object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator firstStageAnchorGenerator_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator, object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder, object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder> firstStageAnchorGeneratorBuilder_;
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public boolean hasFirstStageAnchorGenerator() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator getFirstStageAnchorGenerator() {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          return firstStageAnchorGenerator_ == null ? object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : firstStageAnchorGenerator_;
        } else {
          return firstStageAnchorGeneratorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public Builder setFirstStageAnchorGenerator(object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator value) {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          firstStageAnchorGenerator_ = value;
          onChanged();
        } else {
          firstStageAnchorGeneratorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public Builder setFirstStageAnchorGenerator(
          object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder builderForValue) {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          firstStageAnchorGenerator_ = builderForValue.build();
          onChanged();
        } else {
          firstStageAnchorGeneratorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public Builder mergeFirstStageAnchorGenerator(object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator value) {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          if (((bitField0_ & 0x00000010) == 0x00000010) &&
              firstStageAnchorGenerator_ != null &&
              firstStageAnchorGenerator_ != object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance()) {
            firstStageAnchorGenerator_ =
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.newBuilder(firstStageAnchorGenerator_).mergeFrom(value).buildPartial();
          } else {
            firstStageAnchorGenerator_ = value;
          }
          onChanged();
        } else {
          firstStageAnchorGeneratorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public Builder clearFirstStageAnchorGenerator() {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          firstStageAnchorGenerator_ = null;
          onChanged();
        } else {
          firstStageAnchorGeneratorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder getFirstStageAnchorGeneratorBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getFirstStageAnchorGeneratorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder getFirstStageAnchorGeneratorOrBuilder() {
        if (firstStageAnchorGeneratorBuilder_ != null) {
          return firstStageAnchorGeneratorBuilder_.getMessageOrBuilder();
        } else {
          return firstStageAnchorGenerator_ == null ?
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : firstStageAnchorGenerator_;
        }
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator, object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder, object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder> 
          getFirstStageAnchorGeneratorFieldBuilder() {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          firstStageAnchorGeneratorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator, object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder, object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder>(
                  getFirstStageAnchorGenerator(),
                  getParentForChildren(),
                  isClean());
          firstStageAnchorGenerator_ = null;
        }
        return firstStageAnchorGeneratorBuilder_;
      }

      private int firstStageAtrousRate_ = 1;
      /**
       * <pre>
       * Atrous rate for the convolution op applied to the
       * `first_stage_features_to_crop` tensor to obtain box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
       */
      public boolean hasFirstStageAtrousRate() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * Atrous rate for the convolution op applied to the
       * `first_stage_features_to_crop` tensor to obtain box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
       */
      public int getFirstStageAtrousRate() {
        return firstStageAtrousRate_;
      }
      /**
       * <pre>
       * Atrous rate for the convolution op applied to the
       * `first_stage_features_to_crop` tensor to obtain box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
       */
      public Builder setFirstStageAtrousRate(int value) {
        bitField0_ |= 0x00000020;
        firstStageAtrousRate_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Atrous rate for the convolution op applied to the
       * `first_stage_features_to_crop` tensor to obtain box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
       */
      public Builder clearFirstStageAtrousRate() {
        bitField0_ = (bitField0_ & ~0x00000020);
        firstStageAtrousRate_ = 1;
        onChanged();
        return this;
      }

      private object_detection.protos.HyperparamsOuterClass.Hyperparams firstStageBoxPredictorConvHyperparams_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder> firstStageBoxPredictorConvHyperparamsBuilder_;
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public boolean hasFirstStageBoxPredictorConvHyperparams() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public object_detection.protos.HyperparamsOuterClass.Hyperparams getFirstStageBoxPredictorConvHyperparams() {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          return firstStageBoxPredictorConvHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : firstStageBoxPredictorConvHyperparams_;
        } else {
          return firstStageBoxPredictorConvHyperparamsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public Builder setFirstStageBoxPredictorConvHyperparams(object_detection.protos.HyperparamsOuterClass.Hyperparams value) {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          firstStageBoxPredictorConvHyperparams_ = value;
          onChanged();
        } else {
          firstStageBoxPredictorConvHyperparamsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public Builder setFirstStageBoxPredictorConvHyperparams(
          object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder builderForValue) {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          firstStageBoxPredictorConvHyperparams_ = builderForValue.build();
          onChanged();
        } else {
          firstStageBoxPredictorConvHyperparamsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public Builder mergeFirstStageBoxPredictorConvHyperparams(object_detection.protos.HyperparamsOuterClass.Hyperparams value) {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040) &&
              firstStageBoxPredictorConvHyperparams_ != null &&
              firstStageBoxPredictorConvHyperparams_ != object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance()) {
            firstStageBoxPredictorConvHyperparams_ =
              object_detection.protos.HyperparamsOuterClass.Hyperparams.newBuilder(firstStageBoxPredictorConvHyperparams_).mergeFrom(value).buildPartial();
          } else {
            firstStageBoxPredictorConvHyperparams_ = value;
          }
          onChanged();
        } else {
          firstStageBoxPredictorConvHyperparamsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public Builder clearFirstStageBoxPredictorConvHyperparams() {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          firstStageBoxPredictorConvHyperparams_ = null;
          onChanged();
        } else {
          firstStageBoxPredictorConvHyperparamsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder getFirstStageBoxPredictorConvHyperparamsBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getFirstStageBoxPredictorConvHyperparamsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getFirstStageBoxPredictorConvHyperparamsOrBuilder() {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ != null) {
          return firstStageBoxPredictorConvHyperparamsBuilder_.getMessageOrBuilder();
        } else {
          return firstStageBoxPredictorConvHyperparams_ == null ?
              object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : firstStageBoxPredictorConvHyperparams_;
        }
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder> 
          getFirstStageBoxPredictorConvHyperparamsFieldBuilder() {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          firstStageBoxPredictorConvHyperparamsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder>(
                  getFirstStageBoxPredictorConvHyperparams(),
                  getParentForChildren(),
                  isClean());
          firstStageBoxPredictorConvHyperparams_ = null;
        }
        return firstStageBoxPredictorConvHyperparamsBuilder_;
      }

      private int firstStageBoxPredictorKernelSize_ = 3;
      /**
       * <pre>
       * Kernel size to use for the convolution op just prior to RPN box
       * predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
       */
      public boolean hasFirstStageBoxPredictorKernelSize() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * Kernel size to use for the convolution op just prior to RPN box
       * predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
       */
      public int getFirstStageBoxPredictorKernelSize() {
        return firstStageBoxPredictorKernelSize_;
      }
      /**
       * <pre>
       * Kernel size to use for the convolution op just prior to RPN box
       * predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
       */
      public Builder setFirstStageBoxPredictorKernelSize(int value) {
        bitField0_ |= 0x00000080;
        firstStageBoxPredictorKernelSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kernel size to use for the convolution op just prior to RPN box
       * predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
       */
      public Builder clearFirstStageBoxPredictorKernelSize() {
        bitField0_ = (bitField0_ & ~0x00000080);
        firstStageBoxPredictorKernelSize_ = 3;
        onChanged();
        return this;
      }

      private int firstStageBoxPredictorDepth_ = 512;
      /**
       * <pre>
       * Output depth for the convolution op just prior to RPN box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
       */
      public boolean hasFirstStageBoxPredictorDepth() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * Output depth for the convolution op just prior to RPN box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
       */
      public int getFirstStageBoxPredictorDepth() {
        return firstStageBoxPredictorDepth_;
      }
      /**
       * <pre>
       * Output depth for the convolution op just prior to RPN box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
       */
      public Builder setFirstStageBoxPredictorDepth(int value) {
        bitField0_ |= 0x00000100;
        firstStageBoxPredictorDepth_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output depth for the convolution op just prior to RPN box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
       */
      public Builder clearFirstStageBoxPredictorDepth() {
        bitField0_ = (bitField0_ & ~0x00000100);
        firstStageBoxPredictorDepth_ = 512;
        onChanged();
        return this;
      }

      private int firstStageMinibatchSize_ = 256;
      /**
       * <pre>
       * The batch size to use for computing the first stage objectness and
       * location losses.
       * </pre>
       *
       * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
       */
      public boolean hasFirstStageMinibatchSize() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <pre>
       * The batch size to use for computing the first stage objectness and
       * location losses.
       * </pre>
       *
       * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
       */
      public int getFirstStageMinibatchSize() {
        return firstStageMinibatchSize_;
      }
      /**
       * <pre>
       * The batch size to use for computing the first stage objectness and
       * location losses.
       * </pre>
       *
       * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
       */
      public Builder setFirstStageMinibatchSize(int value) {
        bitField0_ |= 0x00000200;
        firstStageMinibatchSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The batch size to use for computing the first stage objectness and
       * location losses.
       * </pre>
       *
       * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
       */
      public Builder clearFirstStageMinibatchSize() {
        bitField0_ = (bitField0_ & ~0x00000200);
        firstStageMinibatchSize_ = 256;
        onChanged();
        return this;
      }

      private float firstStagePositiveBalanceFraction_ = 0.5F;
      /**
       * <pre>
       * Fraction of positive examples per image for the RPN.
       * </pre>
       *
       * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
       */
      public boolean hasFirstStagePositiveBalanceFraction() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <pre>
       * Fraction of positive examples per image for the RPN.
       * </pre>
       *
       * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
       */
      public float getFirstStagePositiveBalanceFraction() {
        return firstStagePositiveBalanceFraction_;
      }
      /**
       * <pre>
       * Fraction of positive examples per image for the RPN.
       * </pre>
       *
       * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
       */
      public Builder setFirstStagePositiveBalanceFraction(float value) {
        bitField0_ |= 0x00000400;
        firstStagePositiveBalanceFraction_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Fraction of positive examples per image for the RPN.
       * </pre>
       *
       * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
       */
      public Builder clearFirstStagePositiveBalanceFraction() {
        bitField0_ = (bitField0_ & ~0x00000400);
        firstStagePositiveBalanceFraction_ = 0.5F;
        onChanged();
        return this;
      }

      private float firstStageNmsScoreThreshold_ ;
      /**
       * <pre>
       * Non max suppression score threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
       */
      public boolean hasFirstStageNmsScoreThreshold() {
        return ((bitField0_ & 0x00000800) == 0x00000800);
      }
      /**
       * <pre>
       * Non max suppression score threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
       */
      public float getFirstStageNmsScoreThreshold() {
        return firstStageNmsScoreThreshold_;
      }
      /**
       * <pre>
       * Non max suppression score threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
       */
      public Builder setFirstStageNmsScoreThreshold(float value) {
        bitField0_ |= 0x00000800;
        firstStageNmsScoreThreshold_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Non max suppression score threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
       */
      public Builder clearFirstStageNmsScoreThreshold() {
        bitField0_ = (bitField0_ & ~0x00000800);
        firstStageNmsScoreThreshold_ = 0F;
        onChanged();
        return this;
      }

      private float firstStageNmsIouThreshold_ = 0.7F;
      /**
       * <pre>
       * Non max suppression IOU threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
       */
      public boolean hasFirstStageNmsIouThreshold() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       * <pre>
       * Non max suppression IOU threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
       */
      public float getFirstStageNmsIouThreshold() {
        return firstStageNmsIouThreshold_;
      }
      /**
       * <pre>
       * Non max suppression IOU threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
       */
      public Builder setFirstStageNmsIouThreshold(float value) {
        bitField0_ |= 0x00001000;
        firstStageNmsIouThreshold_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Non max suppression IOU threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
       */
      public Builder clearFirstStageNmsIouThreshold() {
        bitField0_ = (bitField0_ & ~0x00001000);
        firstStageNmsIouThreshold_ = 0.7F;
        onChanged();
        return this;
      }

      private int firstStageMaxProposals_ = 300;
      /**
       * <pre>
       * Maximum number of RPN proposals retained after first stage postprocessing.
       * </pre>
       *
       * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
       */
      public boolean hasFirstStageMaxProposals() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       * <pre>
       * Maximum number of RPN proposals retained after first stage postprocessing.
       * </pre>
       *
       * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
       */
      public int getFirstStageMaxProposals() {
        return firstStageMaxProposals_;
      }
      /**
       * <pre>
       * Maximum number of RPN proposals retained after first stage postprocessing.
       * </pre>
       *
       * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
       */
      public Builder setFirstStageMaxProposals(int value) {
        bitField0_ |= 0x00002000;
        firstStageMaxProposals_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum number of RPN proposals retained after first stage postprocessing.
       * </pre>
       *
       * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
       */
      public Builder clearFirstStageMaxProposals() {
        bitField0_ = (bitField0_ & ~0x00002000);
        firstStageMaxProposals_ = 300;
        onChanged();
        return this;
      }

      private float firstStageLocalizationLossWeight_ = 1F;
      /**
       * <pre>
       * First stage RPN localization loss weight.
       * </pre>
       *
       * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
       */
      public boolean hasFirstStageLocalizationLossWeight() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       * <pre>
       * First stage RPN localization loss weight.
       * </pre>
       *
       * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
       */
      public float getFirstStageLocalizationLossWeight() {
        return firstStageLocalizationLossWeight_;
      }
      /**
       * <pre>
       * First stage RPN localization loss weight.
       * </pre>
       *
       * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
       */
      public Builder setFirstStageLocalizationLossWeight(float value) {
        bitField0_ |= 0x00004000;
        firstStageLocalizationLossWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * First stage RPN localization loss weight.
       * </pre>
       *
       * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
       */
      public Builder clearFirstStageLocalizationLossWeight() {
        bitField0_ = (bitField0_ & ~0x00004000);
        firstStageLocalizationLossWeight_ = 1F;
        onChanged();
        return this;
      }

      private float firstStageObjectnessLossWeight_ = 1F;
      /**
       * <pre>
       * First stage RPN objectness loss weight.
       * </pre>
       *
       * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
       */
      public boolean hasFirstStageObjectnessLossWeight() {
        return ((bitField0_ & 0x00008000) == 0x00008000);
      }
      /**
       * <pre>
       * First stage RPN objectness loss weight.
       * </pre>
       *
       * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
       */
      public float getFirstStageObjectnessLossWeight() {
        return firstStageObjectnessLossWeight_;
      }
      /**
       * <pre>
       * First stage RPN objectness loss weight.
       * </pre>
       *
       * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
       */
      public Builder setFirstStageObjectnessLossWeight(float value) {
        bitField0_ |= 0x00008000;
        firstStageObjectnessLossWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * First stage RPN objectness loss weight.
       * </pre>
       *
       * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
       */
      public Builder clearFirstStageObjectnessLossWeight() {
        bitField0_ = (bitField0_ & ~0x00008000);
        firstStageObjectnessLossWeight_ = 1F;
        onChanged();
        return this;
      }

      private int initialCropSize_ ;
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling.
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 18;</code>
       */
      public boolean hasInitialCropSize() {
        return ((bitField0_ & 0x00010000) == 0x00010000);
      }
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling.
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 18;</code>
       */
      public int getInitialCropSize() {
        return initialCropSize_;
      }
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling.
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 18;</code>
       */
      public Builder setInitialCropSize(int value) {
        bitField0_ |= 0x00010000;
        initialCropSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling.
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 18;</code>
       */
      public Builder clearInitialCropSize() {
        bitField0_ = (bitField0_ & ~0x00010000);
        initialCropSize_ = 0;
        onChanged();
        return this;
      }

      private int maxpoolKernelSize_ ;
      /**
       * <pre>
       * Kernel size of the max pool op on the cropped feature map during
       * ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_kernel_size = 19;</code>
       */
      public boolean hasMaxpoolKernelSize() {
        return ((bitField0_ & 0x00020000) == 0x00020000);
      }
      /**
       * <pre>
       * Kernel size of the max pool op on the cropped feature map during
       * ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_kernel_size = 19;</code>
       */
      public int getMaxpoolKernelSize() {
        return maxpoolKernelSize_;
      }
      /**
       * <pre>
       * Kernel size of the max pool op on the cropped feature map during
       * ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_kernel_size = 19;</code>
       */
      public Builder setMaxpoolKernelSize(int value) {
        bitField0_ |= 0x00020000;
        maxpoolKernelSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kernel size of the max pool op on the cropped feature map during
       * ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_kernel_size = 19;</code>
       */
      public Builder clearMaxpoolKernelSize() {
        bitField0_ = (bitField0_ & ~0x00020000);
        maxpoolKernelSize_ = 0;
        onChanged();
        return this;
      }

      private int maxpoolStride_ ;
      /**
       * <pre>
       * Stride of the max pool op on the cropped feature map during ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_stride = 20;</code>
       */
      public boolean hasMaxpoolStride() {
        return ((bitField0_ & 0x00040000) == 0x00040000);
      }
      /**
       * <pre>
       * Stride of the max pool op on the cropped feature map during ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_stride = 20;</code>
       */
      public int getMaxpoolStride() {
        return maxpoolStride_;
      }
      /**
       * <pre>
       * Stride of the max pool op on the cropped feature map during ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_stride = 20;</code>
       */
      public Builder setMaxpoolStride(int value) {
        bitField0_ |= 0x00040000;
        maxpoolStride_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Stride of the max pool op on the cropped feature map during ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_stride = 20;</code>
       */
      public Builder clearMaxpoolStride() {
        bitField0_ = (bitField0_ & ~0x00040000);
        maxpoolStride_ = 0;
        onChanged();
        return this;
      }

      private object_detection.protos.BoxPredictorOuterClass.BoxPredictor secondStageBoxPredictor_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.BoxPredictorOuterClass.BoxPredictor, object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder, object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder> secondStageBoxPredictorBuilder_;
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public boolean hasSecondStageBoxPredictor() {
        return ((bitField0_ & 0x00080000) == 0x00080000);
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public object_detection.protos.BoxPredictorOuterClass.BoxPredictor getSecondStageBoxPredictor() {
        if (secondStageBoxPredictorBuilder_ == null) {
          return secondStageBoxPredictor_ == null ? object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : secondStageBoxPredictor_;
        } else {
          return secondStageBoxPredictorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public Builder setSecondStageBoxPredictor(object_detection.protos.BoxPredictorOuterClass.BoxPredictor value) {
        if (secondStageBoxPredictorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          secondStageBoxPredictor_ = value;
          onChanged();
        } else {
          secondStageBoxPredictorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00080000;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public Builder setSecondStageBoxPredictor(
          object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder builderForValue) {
        if (secondStageBoxPredictorBuilder_ == null) {
          secondStageBoxPredictor_ = builderForValue.build();
          onChanged();
        } else {
          secondStageBoxPredictorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00080000;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public Builder mergeSecondStageBoxPredictor(object_detection.protos.BoxPredictorOuterClass.BoxPredictor value) {
        if (secondStageBoxPredictorBuilder_ == null) {
          if (((bitField0_ & 0x00080000) == 0x00080000) &&
              secondStageBoxPredictor_ != null &&
              secondStageBoxPredictor_ != object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance()) {
            secondStageBoxPredictor_ =
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor.newBuilder(secondStageBoxPredictor_).mergeFrom(value).buildPartial();
          } else {
            secondStageBoxPredictor_ = value;
          }
          onChanged();
        } else {
          secondStageBoxPredictorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00080000;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public Builder clearSecondStageBoxPredictor() {
        if (secondStageBoxPredictorBuilder_ == null) {
          secondStageBoxPredictor_ = null;
          onChanged();
        } else {
          secondStageBoxPredictorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00080000);
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder getSecondStageBoxPredictorBuilder() {
        bitField0_ |= 0x00080000;
        onChanged();
        return getSecondStageBoxPredictorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder getSecondStageBoxPredictorOrBuilder() {
        if (secondStageBoxPredictorBuilder_ != null) {
          return secondStageBoxPredictorBuilder_.getMessageOrBuilder();
        } else {
          return secondStageBoxPredictor_ == null ?
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : secondStageBoxPredictor_;
        }
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.BoxPredictorOuterClass.BoxPredictor, object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder, object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder> 
          getSecondStageBoxPredictorFieldBuilder() {
        if (secondStageBoxPredictorBuilder_ == null) {
          secondStageBoxPredictorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor, object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder, object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder>(
                  getSecondStageBoxPredictor(),
                  getParentForChildren(),
                  isClean());
          secondStageBoxPredictor_ = null;
        }
        return secondStageBoxPredictorBuilder_;
      }

      private int secondStageBatchSize_ = 64;
      /**
       * <pre>
       * The batch size per image used for computing the classification and refined
       * location loss of the box classifier.
       * Note that this field is ignored if `hard_example_miner` is configured.
       * </pre>
       *
       * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
       */
      public boolean hasSecondStageBatchSize() {
        return ((bitField0_ & 0x00100000) == 0x00100000);
      }
      /**
       * <pre>
       * The batch size per image used for computing the classification and refined
       * location loss of the box classifier.
       * Note that this field is ignored if `hard_example_miner` is configured.
       * </pre>
       *
       * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
       */
      public int getSecondStageBatchSize() {
        return secondStageBatchSize_;
      }
      /**
       * <pre>
       * The batch size per image used for computing the classification and refined
       * location loss of the box classifier.
       * Note that this field is ignored if `hard_example_miner` is configured.
       * </pre>
       *
       * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
       */
      public Builder setSecondStageBatchSize(int value) {
        bitField0_ |= 0x00100000;
        secondStageBatchSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The batch size per image used for computing the classification and refined
       * location loss of the box classifier.
       * Note that this field is ignored if `hard_example_miner` is configured.
       * </pre>
       *
       * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
       */
      public Builder clearSecondStageBatchSize() {
        bitField0_ = (bitField0_ & ~0x00100000);
        secondStageBatchSize_ = 64;
        onChanged();
        return this;
      }

      private float secondStageBalanceFraction_ = 0.25F;
      /**
       * <pre>
       * Fraction of positive examples to use per image for the box classifier.
       * </pre>
       *
       * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
       */
      public boolean hasSecondStageBalanceFraction() {
        return ((bitField0_ & 0x00200000) == 0x00200000);
      }
      /**
       * <pre>
       * Fraction of positive examples to use per image for the box classifier.
       * </pre>
       *
       * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
       */
      public float getSecondStageBalanceFraction() {
        return secondStageBalanceFraction_;
      }
      /**
       * <pre>
       * Fraction of positive examples to use per image for the box classifier.
       * </pre>
       *
       * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
       */
      public Builder setSecondStageBalanceFraction(float value) {
        bitField0_ |= 0x00200000;
        secondStageBalanceFraction_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Fraction of positive examples to use per image for the box classifier.
       * </pre>
       *
       * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
       */
      public Builder clearSecondStageBalanceFraction() {
        bitField0_ = (bitField0_ & ~0x00200000);
        secondStageBalanceFraction_ = 0.25F;
        onChanged();
        return this;
      }

      private object_detection.protos.PostProcessingOuterClass.PostProcessing secondStagePostProcessing_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.PostProcessingOuterClass.PostProcessing, object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder, object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder> secondStagePostProcessingBuilder_;
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public boolean hasSecondStagePostProcessing() {
        return ((bitField0_ & 0x00400000) == 0x00400000);
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public object_detection.protos.PostProcessingOuterClass.PostProcessing getSecondStagePostProcessing() {
        if (secondStagePostProcessingBuilder_ == null) {
          return secondStagePostProcessing_ == null ? object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : secondStagePostProcessing_;
        } else {
          return secondStagePostProcessingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public Builder setSecondStagePostProcessing(object_detection.protos.PostProcessingOuterClass.PostProcessing value) {
        if (secondStagePostProcessingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          secondStagePostProcessing_ = value;
          onChanged();
        } else {
          secondStagePostProcessingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00400000;
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public Builder setSecondStagePostProcessing(
          object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder builderForValue) {
        if (secondStagePostProcessingBuilder_ == null) {
          secondStagePostProcessing_ = builderForValue.build();
          onChanged();
        } else {
          secondStagePostProcessingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00400000;
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public Builder mergeSecondStagePostProcessing(object_detection.protos.PostProcessingOuterClass.PostProcessing value) {
        if (secondStagePostProcessingBuilder_ == null) {
          if (((bitField0_ & 0x00400000) == 0x00400000) &&
              secondStagePostProcessing_ != null &&
              secondStagePostProcessing_ != object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance()) {
            secondStagePostProcessing_ =
              object_detection.protos.PostProcessingOuterClass.PostProcessing.newBuilder(secondStagePostProcessing_).mergeFrom(value).buildPartial();
          } else {
            secondStagePostProcessing_ = value;
          }
          onChanged();
        } else {
          secondStagePostProcessingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00400000;
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public Builder clearSecondStagePostProcessing() {
        if (secondStagePostProcessingBuilder_ == null) {
          secondStagePostProcessing_ = null;
          onChanged();
        } else {
          secondStagePostProcessingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00400000);
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder getSecondStagePostProcessingBuilder() {
        bitField0_ |= 0x00400000;
        onChanged();
        return getSecondStagePostProcessingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder getSecondStagePostProcessingOrBuilder() {
        if (secondStagePostProcessingBuilder_ != null) {
          return secondStagePostProcessingBuilder_.getMessageOrBuilder();
        } else {
          return secondStagePostProcessing_ == null ?
              object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : secondStagePostProcessing_;
        }
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.PostProcessingOuterClass.PostProcessing, object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder, object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder> 
          getSecondStagePostProcessingFieldBuilder() {
        if (secondStagePostProcessingBuilder_ == null) {
          secondStagePostProcessingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.PostProcessingOuterClass.PostProcessing, object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder, object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder>(
                  getSecondStagePostProcessing(),
                  getParentForChildren(),
                  isClean());
          secondStagePostProcessing_ = null;
        }
        return secondStagePostProcessingBuilder_;
      }

      private float secondStageLocalizationLossWeight_ = 1F;
      /**
       * <pre>
       * Second stage refined localization loss weight.
       * </pre>
       *
       * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
       */
      public boolean hasSecondStageLocalizationLossWeight() {
        return ((bitField0_ & 0x00800000) == 0x00800000);
      }
      /**
       * <pre>
       * Second stage refined localization loss weight.
       * </pre>
       *
       * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
       */
      public float getSecondStageLocalizationLossWeight() {
        return secondStageLocalizationLossWeight_;
      }
      /**
       * <pre>
       * Second stage refined localization loss weight.
       * </pre>
       *
       * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
       */
      public Builder setSecondStageLocalizationLossWeight(float value) {
        bitField0_ |= 0x00800000;
        secondStageLocalizationLossWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Second stage refined localization loss weight.
       * </pre>
       *
       * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
       */
      public Builder clearSecondStageLocalizationLossWeight() {
        bitField0_ = (bitField0_ & ~0x00800000);
        secondStageLocalizationLossWeight_ = 1F;
        onChanged();
        return this;
      }

      private float secondStageClassificationLossWeight_ = 1F;
      /**
       * <pre>
       * Second stage classification loss weight
       * </pre>
       *
       * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
       */
      public boolean hasSecondStageClassificationLossWeight() {
        return ((bitField0_ & 0x01000000) == 0x01000000);
      }
      /**
       * <pre>
       * Second stage classification loss weight
       * </pre>
       *
       * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
       */
      public float getSecondStageClassificationLossWeight() {
        return secondStageClassificationLossWeight_;
      }
      /**
       * <pre>
       * Second stage classification loss weight
       * </pre>
       *
       * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
       */
      public Builder setSecondStageClassificationLossWeight(float value) {
        bitField0_ |= 0x01000000;
        secondStageClassificationLossWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Second stage classification loss weight
       * </pre>
       *
       * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
       */
      public Builder clearSecondStageClassificationLossWeight() {
        bitField0_ = (bitField0_ & ~0x01000000);
        secondStageClassificationLossWeight_ = 1F;
        onChanged();
        return this;
      }

      private float secondStageMaskPredictionLossWeight_ = 1F;
      /**
       * <pre>
       * Second stage instance mask loss weight. Note that this is only applicable
       * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
       * predict instance masks.
       * </pre>
       *
       * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
       */
      public boolean hasSecondStageMaskPredictionLossWeight() {
        return ((bitField0_ & 0x02000000) == 0x02000000);
      }
      /**
       * <pre>
       * Second stage instance mask loss weight. Note that this is only applicable
       * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
       * predict instance masks.
       * </pre>
       *
       * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
       */
      public float getSecondStageMaskPredictionLossWeight() {
        return secondStageMaskPredictionLossWeight_;
      }
      /**
       * <pre>
       * Second stage instance mask loss weight. Note that this is only applicable
       * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
       * predict instance masks.
       * </pre>
       *
       * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
       */
      public Builder setSecondStageMaskPredictionLossWeight(float value) {
        bitField0_ |= 0x02000000;
        secondStageMaskPredictionLossWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Second stage instance mask loss weight. Note that this is only applicable
       * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
       * predict instance masks.
       * </pre>
       *
       * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
       */
      public Builder clearSecondStageMaskPredictionLossWeight() {
        bitField0_ = (bitField0_ & ~0x02000000);
        secondStageMaskPredictionLossWeight_ = 1F;
        onChanged();
        return this;
      }

      private object_detection.protos.Losses.HardExampleMiner hardExampleMiner_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Losses.HardExampleMiner, object_detection.protos.Losses.HardExampleMiner.Builder, object_detection.protos.Losses.HardExampleMinerOrBuilder> hardExampleMinerBuilder_;
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public boolean hasHardExampleMiner() {
        return ((bitField0_ & 0x04000000) == 0x04000000);
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public object_detection.protos.Losses.HardExampleMiner getHardExampleMiner() {
        if (hardExampleMinerBuilder_ == null) {
          return hardExampleMiner_ == null ? object_detection.protos.Losses.HardExampleMiner.getDefaultInstance() : hardExampleMiner_;
        } else {
          return hardExampleMinerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public Builder setHardExampleMiner(object_detection.protos.Losses.HardExampleMiner value) {
        if (hardExampleMinerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          hardExampleMiner_ = value;
          onChanged();
        } else {
          hardExampleMinerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x04000000;
        return this;
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public Builder setHardExampleMiner(
          object_detection.protos.Losses.HardExampleMiner.Builder builderForValue) {
        if (hardExampleMinerBuilder_ == null) {
          hardExampleMiner_ = builderForValue.build();
          onChanged();
        } else {
          hardExampleMinerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x04000000;
        return this;
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public Builder mergeHardExampleMiner(object_detection.protos.Losses.HardExampleMiner value) {
        if (hardExampleMinerBuilder_ == null) {
          if (((bitField0_ & 0x04000000) == 0x04000000) &&
              hardExampleMiner_ != null &&
              hardExampleMiner_ != object_detection.protos.Losses.HardExampleMiner.getDefaultInstance()) {
            hardExampleMiner_ =
              object_detection.protos.Losses.HardExampleMiner.newBuilder(hardExampleMiner_).mergeFrom(value).buildPartial();
          } else {
            hardExampleMiner_ = value;
          }
          onChanged();
        } else {
          hardExampleMinerBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x04000000;
        return this;
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public Builder clearHardExampleMiner() {
        if (hardExampleMinerBuilder_ == null) {
          hardExampleMiner_ = null;
          onChanged();
        } else {
          hardExampleMinerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x04000000);
        return this;
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public object_detection.protos.Losses.HardExampleMiner.Builder getHardExampleMinerBuilder() {
        bitField0_ |= 0x04000000;
        onChanged();
        return getHardExampleMinerFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public object_detection.protos.Losses.HardExampleMinerOrBuilder getHardExampleMinerOrBuilder() {
        if (hardExampleMinerBuilder_ != null) {
          return hardExampleMinerBuilder_.getMessageOrBuilder();
        } else {
          return hardExampleMiner_ == null ?
              object_detection.protos.Losses.HardExampleMiner.getDefaultInstance() : hardExampleMiner_;
        }
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Losses.HardExampleMiner, object_detection.protos.Losses.HardExampleMiner.Builder, object_detection.protos.Losses.HardExampleMinerOrBuilder> 
          getHardExampleMinerFieldBuilder() {
        if (hardExampleMinerBuilder_ == null) {
          hardExampleMinerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.Losses.HardExampleMiner, object_detection.protos.Losses.HardExampleMiner.Builder, object_detection.protos.Losses.HardExampleMinerOrBuilder>(
                  getHardExampleMiner(),
                  getParentForChildren(),
                  isClean());
          hardExampleMiner_ = null;
        }
        return hardExampleMinerBuilder_;
      }

      private object_detection.protos.Losses.ClassificationLoss secondStageClassificationLoss_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder> secondStageClassificationLossBuilder_;
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public boolean hasSecondStageClassificationLoss() {
        return ((bitField0_ & 0x08000000) == 0x08000000);
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public object_detection.protos.Losses.ClassificationLoss getSecondStageClassificationLoss() {
        if (secondStageClassificationLossBuilder_ == null) {
          return secondStageClassificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : secondStageClassificationLoss_;
        } else {
          return secondStageClassificationLossBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public Builder setSecondStageClassificationLoss(object_detection.protos.Losses.ClassificationLoss value) {
        if (secondStageClassificationLossBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          secondStageClassificationLoss_ = value;
          onChanged();
        } else {
          secondStageClassificationLossBuilder_.setMessage(value);
        }
        bitField0_ |= 0x08000000;
        return this;
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public Builder setSecondStageClassificationLoss(
          object_detection.protos.Losses.ClassificationLoss.Builder builderForValue) {
        if (secondStageClassificationLossBuilder_ == null) {
          secondStageClassificationLoss_ = builderForValue.build();
          onChanged();
        } else {
          secondStageClassificationLossBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x08000000;
        return this;
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public Builder mergeSecondStageClassificationLoss(object_detection.protos.Losses.ClassificationLoss value) {
        if (secondStageClassificationLossBuilder_ == null) {
          if (((bitField0_ & 0x08000000) == 0x08000000) &&
              secondStageClassificationLoss_ != null &&
              secondStageClassificationLoss_ != object_detection.protos.Losses.ClassificationLoss.getDefaultInstance()) {
            secondStageClassificationLoss_ =
              object_detection.protos.Losses.ClassificationLoss.newBuilder(secondStageClassificationLoss_).mergeFrom(value).buildPartial();
          } else {
            secondStageClassificationLoss_ = value;
          }
          onChanged();
        } else {
          secondStageClassificationLossBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x08000000;
        return this;
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public Builder clearSecondStageClassificationLoss() {
        if (secondStageClassificationLossBuilder_ == null) {
          secondStageClassificationLoss_ = null;
          onChanged();
        } else {
          secondStageClassificationLossBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x08000000);
        return this;
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public object_detection.protos.Losses.ClassificationLoss.Builder getSecondStageClassificationLossBuilder() {
        bitField0_ |= 0x08000000;
        onChanged();
        return getSecondStageClassificationLossFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public object_detection.protos.Losses.ClassificationLossOrBuilder getSecondStageClassificationLossOrBuilder() {
        if (secondStageClassificationLossBuilder_ != null) {
          return secondStageClassificationLossBuilder_.getMessageOrBuilder();
        } else {
          return secondStageClassificationLoss_ == null ?
              object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : secondStageClassificationLoss_;
        }
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder> 
          getSecondStageClassificationLossFieldBuilder() {
        if (secondStageClassificationLossBuilder_ == null) {
          secondStageClassificationLossBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder>(
                  getSecondStageClassificationLoss(),
                  getParentForChildren(),
                  isClean());
          secondStageClassificationLoss_ = null;
        }
        return secondStageClassificationLossBuilder_;
      }

      private boolean inplaceBatchnormUpdate_ ;
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
       */
      public boolean hasInplaceBatchnormUpdate() {
        return ((bitField0_ & 0x10000000) == 0x10000000);
      }
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
       */
      public boolean getInplaceBatchnormUpdate() {
        return inplaceBatchnormUpdate_;
      }
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
       */
      public Builder setInplaceBatchnormUpdate(boolean value) {
        bitField0_ |= 0x10000000;
        inplaceBatchnormUpdate_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
       */
      public Builder clearInplaceBatchnormUpdate() {
        bitField0_ = (bitField0_ & ~0x10000000);
        inplaceBatchnormUpdate_ = false;
        onChanged();
        return this;
      }

      private boolean useMatmulCropAndResize_ ;
      /**
       * <pre>
       * Force the use of matrix multiplication based crop and resize instead of
       * standard tf.image.crop_and_resize while computing second stage input
       * feature maps.
       * </pre>
       *
       * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
       */
      public boolean hasUseMatmulCropAndResize() {
        return ((bitField0_ & 0x20000000) == 0x20000000);
      }
      /**
       * <pre>
       * Force the use of matrix multiplication based crop and resize instead of
       * standard tf.image.crop_and_resize while computing second stage input
       * feature maps.
       * </pre>
       *
       * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
       */
      public boolean getUseMatmulCropAndResize() {
        return useMatmulCropAndResize_;
      }
      /**
       * <pre>
       * Force the use of matrix multiplication based crop and resize instead of
       * standard tf.image.crop_and_resize while computing second stage input
       * feature maps.
       * </pre>
       *
       * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
       */
      public Builder setUseMatmulCropAndResize(boolean value) {
        bitField0_ |= 0x20000000;
        useMatmulCropAndResize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Force the use of matrix multiplication based crop and resize instead of
       * standard tf.image.crop_and_resize while computing second stage input
       * feature maps.
       * </pre>
       *
       * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
       */
      public Builder clearUseMatmulCropAndResize() {
        bitField0_ = (bitField0_ & ~0x20000000);
        useMatmulCropAndResize_ = false;
        onChanged();
        return this;
      }

      private boolean clipAnchorsToImage_ ;
      /**
       * <pre>
       * Normally, anchors generated for a given image size are pruned during
       * training if they lie outside the image window. Setting this option to true,
       * clips the anchors to be within the image instead of pruning.
       * </pre>
       *
       * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
       */
      public boolean hasClipAnchorsToImage() {
        return ((bitField0_ & 0x40000000) == 0x40000000);
      }
      /**
       * <pre>
       * Normally, anchors generated for a given image size are pruned during
       * training if they lie outside the image window. Setting this option to true,
       * clips the anchors to be within the image instead of pruning.
       * </pre>
       *
       * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
       */
      public boolean getClipAnchorsToImage() {
        return clipAnchorsToImage_;
      }
      /**
       * <pre>
       * Normally, anchors generated for a given image size are pruned during
       * training if they lie outside the image window. Setting this option to true,
       * clips the anchors to be within the image instead of pruning.
       * </pre>
       *
       * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
       */
      public Builder setClipAnchorsToImage(boolean value) {
        bitField0_ |= 0x40000000;
        clipAnchorsToImage_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Normally, anchors generated for a given image size are pruned during
       * training if they lie outside the image window. Setting this option to true,
       * clips the anchors to be within the image instead of pruning.
       * </pre>
       *
       * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
       */
      public Builder clearClipAnchorsToImage() {
        bitField0_ = (bitField0_ & ~0x40000000);
        clipAnchorsToImage_ = false;
        onChanged();
        return this;
      }

      private boolean useMatmulGatherInMatcher_ ;
      /**
       * <pre>
       * After peforming matching between anchors and targets, in order to pull out
       * targets for training Faster R-CNN meta architecture we perform a gather
       * operation. This options specifies whether to use an alternate
       * implementation of tf.gather that is faster on TPUs.
       * </pre>
       *
       * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
       */
      public boolean hasUseMatmulGatherInMatcher() {
        return ((bitField0_ & 0x80000000) == 0x80000000);
      }
      /**
       * <pre>
       * After peforming matching between anchors and targets, in order to pull out
       * targets for training Faster R-CNN meta architecture we perform a gather
       * operation. This options specifies whether to use an alternate
       * implementation of tf.gather that is faster on TPUs.
       * </pre>
       *
       * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
       */
      public boolean getUseMatmulGatherInMatcher() {
        return useMatmulGatherInMatcher_;
      }
      /**
       * <pre>
       * After peforming matching between anchors and targets, in order to pull out
       * targets for training Faster R-CNN meta architecture we perform a gather
       * operation. This options specifies whether to use an alternate
       * implementation of tf.gather that is faster on TPUs.
       * </pre>
       *
       * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
       */
      public Builder setUseMatmulGatherInMatcher(boolean value) {
        bitField0_ |= 0x80000000;
        useMatmulGatherInMatcher_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * After peforming matching between anchors and targets, in order to pull out
       * targets for training Faster R-CNN meta architecture we perform a gather
       * operation. This options specifies whether to use an alternate
       * implementation of tf.gather that is faster on TPUs.
       * </pre>
       *
       * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
       */
      public Builder clearUseMatmulGatherInMatcher() {
        bitField0_ = (bitField0_ & ~0x80000000);
        useMatmulGatherInMatcher_ = false;
        onChanged();
        return this;
      }

      private boolean useStaticBalancedLabelSampler_ ;
      /**
       * <pre>
       * Whether to use the balanced positive negative sampler implementation with
       * static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
       */
      public boolean hasUseStaticBalancedLabelSampler() {
        return ((bitField1_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Whether to use the balanced positive negative sampler implementation with
       * static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
       */
      public boolean getUseStaticBalancedLabelSampler() {
        return useStaticBalancedLabelSampler_;
      }
      /**
       * <pre>
       * Whether to use the balanced positive negative sampler implementation with
       * static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
       */
      public Builder setUseStaticBalancedLabelSampler(boolean value) {
        bitField1_ |= 0x00000001;
        useStaticBalancedLabelSampler_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use the balanced positive negative sampler implementation with
       * static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
       */
      public Builder clearUseStaticBalancedLabelSampler() {
        bitField1_ = (bitField1_ & ~0x00000001);
        useStaticBalancedLabelSampler_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.FasterRcnn)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.FasterRcnn)
    private static final object_detection.protos.FasterRcnnOuterClass.FasterRcnn DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.FasterRcnnOuterClass.FasterRcnn();
    }

    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<FasterRcnn>
        PARSER = new com.google.protobuf.AbstractParser<FasterRcnn>() {
      @java.lang.Override
      public FasterRcnn parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new FasterRcnn(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<FasterRcnn> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FasterRcnn> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.FasterRcnnOuterClass.FasterRcnn getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface FasterRcnnFeatureExtractorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.FasterRcnnFeatureExtractor)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    boolean hasType();
    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Output stride of extracted RPN feature map.
     * </pre>
     *
     * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
     */
    boolean hasFirstStageFeaturesStride();
    /**
     * <pre>
     * Output stride of extracted RPN feature map.
     * </pre>
     *
     * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
     */
    int getFirstStageFeaturesStride();

    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative large batch size (e.g. 8), it could be
     * desirable to enable batch norm update.
     * </pre>
     *
     * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
     */
    boolean hasBatchNormTrainable();
    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative large batch size (e.g. 8), it could be
     * desirable to enable batch norm update.
     * </pre>
     *
     * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
     */
    boolean getBatchNormTrainable();
  }
  /**
   * Protobuf type {@code object_detection.protos.FasterRcnnFeatureExtractor}
   */
  public  static final class FasterRcnnFeatureExtractor extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.FasterRcnnFeatureExtractor)
      FasterRcnnFeatureExtractorOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use FasterRcnnFeatureExtractor.newBuilder() to construct.
    private FasterRcnnFeatureExtractor(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private FasterRcnnFeatureExtractor() {
      type_ = "";
      firstStageFeaturesStride_ = 16;
      batchNormTrainable_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private FasterRcnnFeatureExtractor(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              type_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              firstStageFeaturesStride_ = input.readInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              batchNormTrainable_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnnFeatureExtractor_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.class, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FIRST_STAGE_FEATURES_STRIDE_FIELD_NUMBER = 2;
    private int firstStageFeaturesStride_;
    /**
     * <pre>
     * Output stride of extracted RPN feature map.
     * </pre>
     *
     * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
     */
    public boolean hasFirstStageFeaturesStride() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Output stride of extracted RPN feature map.
     * </pre>
     *
     * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
     */
    public int getFirstStageFeaturesStride() {
      return firstStageFeaturesStride_;
    }

    public static final int BATCH_NORM_TRAINABLE_FIELD_NUMBER = 3;
    private boolean batchNormTrainable_;
    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative large batch size (e.g. 8), it could be
     * desirable to enable batch norm update.
     * </pre>
     *
     * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
     */
    public boolean hasBatchNormTrainable() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative large batch size (e.g. 8), it could be
     * desirable to enable batch norm update.
     * </pre>
     *
     * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
     */
    public boolean getBatchNormTrainable() {
      return batchNormTrainable_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, firstStageFeaturesStride_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(3, batchNormTrainable_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, firstStageFeaturesStride_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, batchNormTrainable_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor)) {
        return super.equals(obj);
      }
      object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor other = (object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor) obj;

      boolean result = true;
      result = result && (hasType() == other.hasType());
      if (hasType()) {
        result = result && getType()
            .equals(other.getType());
      }
      result = result && (hasFirstStageFeaturesStride() == other.hasFirstStageFeaturesStride());
      if (hasFirstStageFeaturesStride()) {
        result = result && (getFirstStageFeaturesStride()
            == other.getFirstStageFeaturesStride());
      }
      result = result && (hasBatchNormTrainable() == other.hasBatchNormTrainable());
      if (hasBatchNormTrainable()) {
        result = result && (getBatchNormTrainable()
            == other.getBatchNormTrainable());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasFirstStageFeaturesStride()) {
        hash = (37 * hash) + FIRST_STAGE_FEATURES_STRIDE_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageFeaturesStride();
      }
      if (hasBatchNormTrainable()) {
        hash = (37 * hash) + BATCH_NORM_TRAINABLE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getBatchNormTrainable());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code object_detection.protos.FasterRcnnFeatureExtractor}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.FasterRcnnFeatureExtractor)
        object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnnFeatureExtractor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.class, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder.class);
      }

      // Construct using object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        firstStageFeaturesStride_ = 16;
        bitField0_ = (bitField0_ & ~0x00000002);
        batchNormTrainable_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getDefaultInstanceForType() {
        return object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor build() {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor buildPartial() {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor result = new object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.firstStageFeaturesStride_ = firstStageFeaturesStride_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.batchNormTrainable_ = batchNormTrainable_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor) {
          return mergeFrom((object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor other) {
        if (other == object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance()) return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasFirstStageFeaturesStride()) {
          setFirstStageFeaturesStride(other.getFirstStageFeaturesStride());
        }
        if (other.hasBatchNormTrainable()) {
          setBatchNormTrainable(other.getBatchNormTrainable());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private int firstStageFeaturesStride_ = 16;
      /**
       * <pre>
       * Output stride of extracted RPN feature map.
       * </pre>
       *
       * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
       */
      public boolean hasFirstStageFeaturesStride() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Output stride of extracted RPN feature map.
       * </pre>
       *
       * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
       */
      public int getFirstStageFeaturesStride() {
        return firstStageFeaturesStride_;
      }
      /**
       * <pre>
       * Output stride of extracted RPN feature map.
       * </pre>
       *
       * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
       */
      public Builder setFirstStageFeaturesStride(int value) {
        bitField0_ |= 0x00000002;
        firstStageFeaturesStride_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output stride of extracted RPN feature map.
       * </pre>
       *
       * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
       */
      public Builder clearFirstStageFeaturesStride() {
        bitField0_ = (bitField0_ & ~0x00000002);
        firstStageFeaturesStride_ = 16;
        onChanged();
        return this;
      }

      private boolean batchNormTrainable_ ;
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative large batch size (e.g. 8), it could be
       * desirable to enable batch norm update.
       * </pre>
       *
       * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
       */
      public boolean hasBatchNormTrainable() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative large batch size (e.g. 8), it could be
       * desirable to enable batch norm update.
       * </pre>
       *
       * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
       */
      public boolean getBatchNormTrainable() {
        return batchNormTrainable_;
      }
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative large batch size (e.g. 8), it could be
       * desirable to enable batch norm update.
       * </pre>
       *
       * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
       */
      public Builder setBatchNormTrainable(boolean value) {
        bitField0_ |= 0x00000004;
        batchNormTrainable_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative large batch size (e.g. 8), it could be
       * desirable to enable batch norm update.
       * </pre>
       *
       * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
       */
      public Builder clearBatchNormTrainable() {
        bitField0_ = (bitField0_ & ~0x00000004);
        batchNormTrainable_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.FasterRcnnFeatureExtractor)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.FasterRcnnFeatureExtractor)
    private static final object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor();
    }

    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<FasterRcnnFeatureExtractor>
        PARSER = new com.google.protobuf.AbstractParser<FasterRcnnFeatureExtractor>() {
      @java.lang.Override
      public FasterRcnnFeatureExtractor parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new FasterRcnnFeatureExtractor(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<FasterRcnnFeatureExtractor> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FasterRcnnFeatureExtractor> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_FasterRcnn_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_FasterRcnn_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_FasterRcnnFeatureExtractor_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n)object_detection/protos/faster_rcnn.pr" +
      "oto\022\027object_detection.protos\032.object_det" +
      "ection/protos/anchor_generator.proto\032+ob" +
      "ject_detection/protos/box_predictor.prot" +
      "o\032)object_detection/protos/hyperparams.p" +
      "roto\032+object_detection/protos/image_resi" +
      "zer.proto\032$object_detection/protos/losse" +
      "s.proto\032-object_detection/protos/post_pr" +
      "ocessing.proto\"\205\r\n\nFasterRcnn\022\033\n\020number_" +
      "of_stages\030\001 \001(\005:\0012\022\023\n\013num_classes\030\003 \001(\005\022" +
      "<\n\rimage_resizer\030\004 \001(\0132%.object_detectio" +
      "n.protos.ImageResizer\022N\n\021feature_extract" +
      "or\030\005 \001(\01323.object_detection.protos.Faste" +
      "rRcnnFeatureExtractor\022N\n\034first_stage_anc" +
      "hor_generator\030\006 \001(\0132(.object_detection.p" +
      "rotos.AnchorGenerator\022\"\n\027first_stage_atr" +
      "ous_rate\030\007 \001(\005:\0011\022X\n*first_stage_box_pre" +
      "dictor_conv_hyperparams\030\010 \001(\0132$.object_d" +
      "etection.protos.Hyperparams\0220\n%first_sta" +
      "ge_box_predictor_kernel_size\030\t \001(\005:\0013\022,\n" +
      "\037first_stage_box_predictor_depth\030\n \001(\005:\003" +
      "512\022\'\n\032first_stage_minibatch_size\030\013 \001(\005:" +
      "\003256\0222\n%first_stage_positive_balance_fra" +
      "ction\030\014 \001(\002:\0030.5\022*\n\037first_stage_nms_scor" +
      "e_threshold\030\r \001(\002:\0010\022*\n\035first_stage_nms_" +
      "iou_threshold\030\016 \001(\002:\0030.7\022&\n\031first_stage_" +
      "max_proposals\030\017 \001(\005:\003300\022/\n$first_stage_" +
      "localization_loss_weight\030\020 \001(\002:\0011\022-\n\"fir" +
      "st_stage_objectness_loss_weight\030\021 \001(\002:\0011" +
      "\022\031\n\021initial_crop_size\030\022 \001(\005\022\033\n\023maxpool_k" +
      "ernel_size\030\023 \001(\005\022\026\n\016maxpool_stride\030\024 \001(\005" +
      "\022I\n\032second_stage_box_predictor\030\025 \001(\0132%.o" +
      "bject_detection.protos.BoxPredictor\022#\n\027s" +
      "econd_stage_batch_size\030\026 \001(\005:\00264\022+\n\035seco" +
      "nd_stage_balance_fraction\030\027 \001(\002:\0040.25\022M\n" +
      "\034second_stage_post_processing\030\030 \001(\0132\'.ob" +
      "ject_detection.protos.PostProcessing\0220\n%" +
      "second_stage_localization_loss_weight\030\031 " +
      "\001(\002:\0011\0222\n\'second_stage_classification_lo" +
      "ss_weight\030\032 \001(\002:\0011\0223\n(second_stage_mask_" +
      "prediction_loss_weight\030\033 \001(\002:\0011\022E\n\022hard_" +
      "example_miner\030\034 \001(\0132).object_detection.p" +
      "rotos.HardExampleMiner\022U\n second_stage_c" +
      "lassification_loss\030\035 \001(\0132+.object_detect" +
      "ion.protos.ClassificationLoss\022\'\n\030inplace" +
      "_batchnorm_update\030\036 \001(\010:\005false\022)\n\032use_ma" +
      "tmul_crop_and_resize\030\037 \001(\010:\005false\022$\n\025cli" +
      "p_anchors_to_image\030  \001(\010:\005false\022+\n\034use_m" +
      "atmul_gather_in_matcher\030! \001(\010:\005false\0220\n!" +
      "use_static_balanced_label_sampler\030\" \001(\010:" +
      "\005false\"x\n\032FasterRcnnFeatureExtractor\022\014\n\004" +
      "type\030\001 \001(\t\022\'\n\033first_stage_features_strid" +
      "e\030\002 \001(\005:\00216\022#\n\024batch_norm_trainable\030\003 \001(" +
      "\010:\005false"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          object_detection.protos.AnchorGeneratorOuterClass.getDescriptor(),
          object_detection.protos.BoxPredictorOuterClass.getDescriptor(),
          object_detection.protos.HyperparamsOuterClass.getDescriptor(),
          object_detection.protos.ImageResizerOuterClass.getDescriptor(),
          object_detection.protos.Losses.getDescriptor(),
          object_detection.protos.PostProcessingOuterClass.getDescriptor(),
        }, assigner);
    internal_static_object_detection_protos_FasterRcnn_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_object_detection_protos_FasterRcnn_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_FasterRcnn_descriptor,
        new java.lang.String[] { "NumberOfStages", "NumClasses", "ImageResizer", "FeatureExtractor", "FirstStageAnchorGenerator", "FirstStageAtrousRate", "FirstStageBoxPredictorConvHyperparams", "FirstStageBoxPredictorKernelSize", "FirstStageBoxPredictorDepth", "FirstStageMinibatchSize", "FirstStagePositiveBalanceFraction", "FirstStageNmsScoreThreshold", "FirstStageNmsIouThreshold", "FirstStageMaxProposals", "FirstStageLocalizationLossWeight", "FirstStageObjectnessLossWeight", "InitialCropSize", "MaxpoolKernelSize", "MaxpoolStride", "SecondStageBoxPredictor", "SecondStageBatchSize", "SecondStageBalanceFraction", "SecondStagePostProcessing", "SecondStageLocalizationLossWeight", "SecondStageClassificationLossWeight", "SecondStageMaskPredictionLossWeight", "HardExampleMiner", "SecondStageClassificationLoss", "InplaceBatchnormUpdate", "UseMatmulCropAndResize", "ClipAnchorsToImage", "UseMatmulGatherInMatcher", "UseStaticBalancedLabelSampler", });
    internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_object_detection_protos_FasterRcnnFeatureExtractor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor,
        new java.lang.String[] { "Type", "FirstStageFeaturesStride", "BatchNormTrainable", });
    object_detection.protos.AnchorGeneratorOuterClass.getDescriptor();
    object_detection.protos.BoxPredictorOuterClass.getDescriptor();
    object_detection.protos.HyperparamsOuterClass.getDescriptor();
    object_detection.protos.ImageResizerOuterClass.getDescriptor();
    object_detection.protos.Losses.getDescriptor();
    object_detection.protos.PostProcessingOuterClass.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
